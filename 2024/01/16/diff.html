<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.57 in css mode. -->
<html>
  <head>
    <title>*Diff*</title>
    <style type="text/css">
    <!--
      body {
        color: #c7c9cb;
        background-color: #232530;
      }
      .diff-added {
        /* diff-added */
        color: #09f7a0;
        background-color: #1c1e26;
      }
      .diff-context {
        /* diff-context */
        color: #afb0b2;
      }
      .diff-file-header {
        /* diff-file-header */
        color: #21bfc2;
      }
      .diff-header {
        /* diff-header */
        color: #59e3e3;
      }
      .diff-hunk-header {
        /* diff-hunk-header */
        color: #b877db;
      }
      .diff-indicator-added {
        /* diff-indicator-added */
        color: #22aa22;
        background-color: #1c1e26;
      }
      .diff-indicator-removed {
        /* diff-indicator-removed */
        color: #aa2222;
        background-color: #232530;
      }
      .diff-refine-added {
        /* diff-refine-added */
        color: #09f7a0;
        background-color: #1c1e26;
      }
      .diff-refine-removed {
        /* diff-refine-removed */
        color: #e95678;
        background-color: #232530;
      }
      .diff-removed {
        /* diff-removed */
        color: #e95678;
        background-color: #232530;
      }
      .hl-line {
        /* hl-line */
        background-color: #1c1e26;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="diff-header">diff -u --label \#\&lt;buffer\ thread_group_impl.cc\&gt; --label \#\&lt;buffer\ thread_group_semaphore.cc\&gt; /tmp/buffer-content-IH0Iuk /tmp/buffer-content-VV4CqS
</span><span class="diff-header"><span class="hl-line">--- </span></span><span class="diff-header"><span class="diff-file-header"><span class="hl-line">#&lt;buffer thread_group_impl.cc&gt;</span></span></span><span class="diff-header"><span class="hl-line">
</span></span><span class="diff-header">+++ </span><span class="diff-header"><span class="diff-file-header">#&lt;buffer thread_group_semaphore.cc&gt;</span></span><span class="diff-header">
</span><span class="diff-hunk-header">@@ -1,94 +1,97 @@</span>
<span class="diff-indicator-removed">-</span><span class="diff-removed">// Copyright 2016 The Chromium Authors
</span><span class="diff-indicator-added">+</span><span class="diff-added">// Copyright 2024 The Chromium Authors
</span><span class="diff-context"> // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/thread_group_impl.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/thread_group_semaphore.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include &lt;algorithm&gt;
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/auto_reset.h"
</span><span class="diff-context"> #include "base/metrics/histogram_macros.h"
 #include "base/sequence_token.h"
 #include "base/strings/string_piece.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/strings/stringprintf.h"
</span><span class="diff-context"> #include "base/task/common/checked_lock.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/thread_group_worker_delegate.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/worker_thread_waitable_event.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/thread_group.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/worker_thread_semaphore.h"
</span><span class="diff-context"> #include "base/threading/scoped_blocking_call.h"
 #include "base/threading/scoped_blocking_call_internal.h"
 #include "base/threading/thread_checker.h"
 #include "base/time/time_override.h"
 #include "base/trace_event/base_tracing.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "third_party/abseil-cpp/absl/container/inlined_vector.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "third_party/abseil-cpp/absl/types/optional.h"
</span><span class="diff-context"> 
 namespace base {
 namespace internal {
 
 namespace {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context"> constexpr size_t kMaxNumberOfWorkers = 256;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context"> }  // namespace
 
 // Upon destruction, executes actions that control the number of active workers.
 // Useful to satisfy locking requirements of these actions.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">class ThreadGroupImpl::ScopedCommandsExecutor
</span><span class="diff-indicator-added">+</span><span class="diff-added">class ThreadGroupSemaphore::SemaphoreScopedCommandsExecutor
</span><span class="diff-context">     : public ThreadGroup::BaseScopedCommandsExecutor {
  public:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  explicit ScopedCommandsExecutor(ThreadGroupImpl* outer)
</span><span class="diff-indicator-added">+</span><span class="diff-added">  explicit SemaphoreScopedCommandsExecutor(ThreadGroupSemaphore* outer)
</span><span class="diff-context">       : BaseScopedCommandsExecutor(outer) {}
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor(const ScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor&amp; operator=(const ScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ~ScopedCommandsExecutor() override {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreScopedCommandsExecutor(const SemaphoreScopedCommandsExecutor&amp;) =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreScopedCommandsExecutor&amp; operator=(
</span><span class="diff-indicator-added">+</span><span class="diff-added">      const SemaphoreScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ~SemaphoreScopedCommandsExecutor() override {
</span><span class="diff-context">     CheckedLock::AssertNoLockHeldOnCurrentThread();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // Wake up workers.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    for (auto worker : workers_to_wake_up_) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      worker-&gt;WakeUp();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    for (int i = 0; i &lt; semaphore_signal_count_; ++i) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      outer()-&gt;semaphore_.Signal();
</span><span class="diff-context">     }
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  void ScheduleWakeUp(scoped_refptr&lt;WorkerThreadWaitableEvent&gt; worker) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    workers_to_wake_up_.emplace_back(std::move(worker));
</span><span class="diff-indicator-added">+</span><span class="diff-added">  void ScheduleSignal() EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    ++semaphore_signal_count_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">    ++outer()-&gt;num_active_signals_;
</span><span class="diff-context">   }
 
  private:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  absl::InlinedVector&lt;scoped_refptr&lt;WorkerThreadWaitableEvent&gt;, 2&gt;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      workers_to_wake_up_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  friend class ThreadGroupSemaphore;
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ThreadGroupSemaphore* outer() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  int semaphore_signal_count_ = 0;
</span><span class="diff-context"> };
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">class ThreadGroupImpl::WaitableEventWorkerDelegate
</span><span class="diff-indicator-added">+</span><span class="diff-added">class ThreadGroupSemaphore::SemaphoreWorkerDelegate
</span><span class="diff-context">     : public ThreadGroup::ThreadGroupWorkerDelegate,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      public WorkerThreadWaitableEvent::Delegate {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      public WorkerThreadSemaphore::Delegate {
</span><span class="diff-context">  public:
   // |outer| owns the worker for which this delegate is constructed. If
   // |is_excess| is true, this worker will be eligible for reclaim.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  explicit WaitableEventWorkerDelegate(TrackedRef&lt;ThreadGroup&gt; outer,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                       bool is_excess);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WaitableEventWorkerDelegate(const WaitableEventWorkerDelegate&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WaitableEventWorkerDelegate&amp; operator=(const WaitableEventWorkerDelegate&amp;) =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  explicit SemaphoreWorkerDelegate(TrackedRef&lt;ThreadGroup&gt; outer,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                   AtomicFlag* join_called_for_testing);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreWorkerDelegate(const SemaphoreWorkerDelegate&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreWorkerDelegate&amp; operator=(const SemaphoreWorkerDelegate&amp;) = delete;
</span><span class="diff-context"> 
   // OnMainExit() handles the thread-affine cleanup;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // WaitableEventWorkerDelegate can thereafter safely be deleted from any
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // thread.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ~WaitableEventWorkerDelegate() override = default;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // SemaphoreWorkerDelegate can thereafter safely be deleted from any thread.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ~SemaphoreWorkerDelegate() override = default;
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // ThreadGroup::Delegate:
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // WorkerThread::Delegate:
</span><span class="diff-context">   void OnMainEntry(WorkerThread* worker) override;
   void OnMainExit(WorkerThread* worker) override;
   RegisteredTaskSource GetWork(WorkerThread* worker) override;
   RegisteredTaskSource SwapProcessedTask(RegisteredTaskSource task_source,
                                          WorkerThread* worker) override;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // WorkerThreadWaitableEvent::Delegate:
</span><span class="diff-context">   void RecordUnnecessaryWakeup() override;
   // True if the calling worker is be eligible for reclaim.
   bool IsExcess() const override;
   TimeDelta GetSleepTimeout() override;
 
  private:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ThreadGroupImpl* outer() const {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return static_cast&lt;ThreadGroupImpl*&gt;(outer_.get());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  const ThreadGroupSemaphore* outer() const {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_.get());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ThreadGroupSemaphore* outer() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_.get());
</span><span class="diff-context">   }
 
   // ThreadGroup::ThreadGroupWorkerDelegate:
</span><span class="diff-hunk-header">@@ -106,59 +109,29 @@</span>
<span class="diff-context">   // thread group. Called from GetWork() when no work is available.
   bool CanCleanupLockRequired(const WorkerThread* worker)
       EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_) override;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const bool is_excess_;
</span><span class="diff-context"> };
 
 std::unique_ptr&lt;ThreadGroup::BaseScopedCommandsExecutor&gt;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::GetExecutor() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::GetExecutor() {
</span><span class="diff-context">   return static_cast&lt;std::unique_ptr&lt;BaseScopedCommandsExecutor&gt;&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      std::make_unique&lt;ScopedCommandsExecutor&gt;(this));
</span><span class="diff-indicator-added">+</span><span class="diff-added">      std::make_unique&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor&gt;(this));
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">(StringPiece histogram_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 StringPiece thread_group_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 ThreadType thread_type_hint,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 TrackedRef&lt;TaskTracker&gt; task_tracker,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 TrackedRef&lt;Delegate&gt; delegate)
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    : ThreadGroup(histogram_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                  thread_group_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                  thread_type_hint,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                  std::move(task_tracker),
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                  std::move(delegate</span><span class="diff-removed"><span class="diff-refine-removed">)),
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      idle_workers_set_cv_for_testing_(lock_.CreateConditionVariable(</span></span><span class="diff-removed">)),
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">(StringPiece histogram_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           StringPiece thread_group_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           ThreadType thread_type_hint,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           TrackedRef&lt;TaskTracker&gt; task_tracker,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           TrackedRef&lt;Delegate&gt; delegate)
</span><span class="diff-indicator-added">+</span><span class="diff-added">    : ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">(histogram_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                      thread_group_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                      thread_type_hint,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                      std::move(task_tracker),
</span><span class="diff-indicator-added">+</span><span class="diff-added">                      std::move(delegate)),
</span><span class="diff-context">       tracked_ref_factory_(this) {
   DCHECK(!thread_group_label_.empty());
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">void ThreadGroupImpl::Start(
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    size_t max_tasks,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    size_t max_best_effort_tasks,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    TimeDelta suggested_reclaim_time,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    scoped_refptr&lt;SingleThreadTaskRunner&gt; service_thread_task_runner,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    WorkerThreadObserver* worker_thread_observer,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    WorkerEnvironment worker_environment,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    bool synchronous_thread_start_for_testing,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    absl::optional&lt;TimeDelta&gt; may_block_threshold) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  ThreadGroup::Start(max_tasks, max_best_effort_tasks, suggested_reclaim_time,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                     service_thread_task_runner, worker_thread_observer,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                     worker_environment, may_block_threshold);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  if (synchronous_thread_start_for_testing) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    worker_started_for_testing_.emplace(WaitableEvent::ResetPolicy::AUTOMATIC);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    // Don't emit a ScopedBlockingCallWithBaseSyncPrimitives from this
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    // WaitableEvent or it defeats the purpose of having threads start without
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    // externally visible side-effects.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    worker_started_for_testing_-&gt;declare_only_used_while_idle();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  }
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  std::unique_ptr&lt;BaseScopedCommandsExecutor&gt; executor = GetExecutor();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  CheckedAutoLock auto_lock(lock_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK(workers_.empty());
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  EnsureEnoughWorkersLockRequired(executor.get());
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::~ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::~ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">() {
</span><span class="diff-context">   // ThreadGroup should only ever be deleted:
   //  1) In tests, after JoinForTesting().
   //  2) In production, iff initialization failed.
</span><span class="diff-hunk-header">@@ -166,93 +139,48 @@</span>
<span class="diff-context">   DCHECK(workers_.empty());
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">void ThreadGroupImpl::UpdateSortKey(TaskSource::Transaction transaction) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  std::unique_ptr&lt;BaseScopedCommandsExecutor&gt; executor = GetExecutor();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  UpdateSortKeyImpl(executor.get(), std::move(transaction));
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">void ThreadGroupImpl::PushTaskSourceAndWakeUpWorkers(
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    RegisteredTaskSourceAndTransaction transaction_with_task_source) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  std::unique_ptr&lt;BaseScopedCommandsExecutor&gt; executor = GetExecutor();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  PushTaskSourceAndWakeUpWorkersImpl(executor.get(),
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                                     std::move(transaction_with_task</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">source));
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">void</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitForWorkersIdleLockRequiredForTesting(size_t n) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // Make sure workers do not cleanup while watching the idle count.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  AutoReset&lt;bool&gt; ban_cleanups(&amp;worker_cleanup_disallowed_for_testing_, true);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  while (</span></span><span class="diff-removed">NumberOfIdleWorkers</span><span class="diff-removed"><span class="diff-refine-removed">LockRequired</span></span><span class="diff-removed">ForTesting() </span><span class="diff-removed"><span class="diff-refine-removed">&lt; n) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    idle_workers_set_cv_for_testing_-&gt;Wait();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  }
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">void ThreadGroupImpl::WaitForWorkersIdleForTesting(size_t n)</span></span><span class="diff-removed"> {
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::NumberOfIdleWorkersForTesting() </span><span class="diff-added"><span class="diff-refine-added">const</span></span><span class="diff-added"> {
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">#if</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK_IS_ON()</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK(!some_workers_cleaned_up_for_testing_)</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">      </span><span class="diff-removed"><span class="diff-refine-removed">&lt;&lt;</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">"Workers</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">detached</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">prior</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">to</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">waiting</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">for</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">a</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">specific</span></span><span class="diff-removed"> number of </span><span class="diff-removed"><span class="diff-refine-removed">idle "
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">         "</span></span><span class="diff-removed">workers. </span><span class="diff-removed"><span class="diff-refine-removed">Doing the wait under such conditions is flaky. Consider "
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">         "setting the suggested reclaim time to TimeDelta::Max() in Start().";
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">#endif</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">WaitFor</span></span><span class="diff-removed">Workers</span><span class="diff-removed"><span class="diff-refine-removed">Idle</span></span><span class="diff-removed">LockRequiredForTesting(</span><span class="diff-removed"><span class="diff-refine-removed">n</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">Subtraction</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">is</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">clamped</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">because</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">the</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">signal</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">count</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">of</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">the</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">semaphore</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">can</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">easily</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">be</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">higher</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">than the</span></span><span class="diff-added"> number of workers.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">return</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">NumberOfIdle</span></span><span class="diff-added">WorkersLockRequiredForTesting();
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">void</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitForAll</span></span><span class="diff-removed">Workers</span><span class="diff-removed"><span class="diff-refine-removed">Idle</span></span><span class="diff-removed">ForTesting() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">CheckedAutoLock</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">auto</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">lock</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">lock</span></span><span class="diff-removed">_)</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">WaitForWorkersIdleLockRequiredForTesting</span></span><span class="diff-removed">(workers_.size());
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">size_t</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">NumberOfIdle</span></span><span class="diff-added">Workers</span><span class="diff-added"><span class="diff-refine-added">LockRequired</span></span><span class="diff-added">ForTesting() </span><span class="diff-added"><span class="diff-refine-added">const</span></span><span class="diff-added"> {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">return</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">std::max(
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">      size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">ClampSub(workers</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">.size(</span></span><span class="diff-added">)</span><span class="diff-added"><span class="diff-refine-added">, max_tasks_)),</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">static_cast&lt;size_t&gt;(ClampSub(static_cast&lt;int64_t&gt;</span></span><span class="diff-added">(workers_.size(</span><span class="diff-added"><span class="diff-refine-added">)),
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">                                   static_cast&lt;int64_t&gt;(num_active_signals_))</span></span><span class="diff-added">));
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">void</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl::WaitForWorkersCleanedUpForTesting(size_t n) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  CheckedAutoLock auto_lock(lock_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  if (!num_workers_cleaned_up_for_testing_cv_) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    num_workers_cleaned_up_for_testing_cv_ = lock_.CreateConditionVariable();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  }
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  while (num_workers_cleaned_up_for_testing_ &lt; n) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    num_workers_cleaned_up_for_testing_cv_-&gt;Wait();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  }
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  num_workers_cleaned_up_for_testing_ = 0;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">ThreadGroupImpl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate(
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate(
</span><span class="diff-context">     TrackedRef&lt;ThreadGroup&gt; outer,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">bool</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">is</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">excess</span></span><span class="diff-removed">)
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    : ThreadGroupWorkerDelegate(std::move(outer)), </span><span class="diff-removed"><span class="diff-refine-removed">is_excess_(is_excess) {</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">// Bound in</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">OnMainEntry().</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DETACH_FROM_THREAD</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker_thread_checker</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">TimeDelta</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl::WaitableEventWorkerDelegate::GetSleepTimeout</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">{</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">ThreadPoolSleepTimeout(</span></span><span class="diff-removed">)</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">}
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">AtomicFlag*</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">join</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">called_for_testing</span></span><span class="diff-added">)
</span><span class="diff-indicator-added">+</span><span class="diff-added">    : ThreadGroupWorkerDelegate(std::move(outer)),
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">Delegate</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">&amp;static</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">cast&lt;</span></span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore*&gt;(outer.get</span></span><span class="diff-added">()</span><span class="diff-added"><span class="diff-refine-added">)-&gt;semaphore_,</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">               </span><span class="diff-added"><span class="diff-refine-added">join_called_for_testing</span></span><span class="diff-added">) </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">}
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::OnMainEntry(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::OnMainEntry(
</span><span class="diff-context">     WorkerThread* worker) {
   OnMainEntryImpl(worker);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::OnMainExit(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::OnMainExit(
</span><span class="diff-context">     WorkerThread* worker_base) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
 
 #if DCHECK_IS_ON()
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context">   {
     bool shutdown_complete = outer()-&gt;task_tracker_-&gt;IsShutdownComplete();
     CheckedAutoLock auto_lock(outer()-&gt;lock_);
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // |worker| should already have been removed from </span><span class="diff-removed"><span class="diff-refine-removed">the idle workers set and
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> |workers_| by the time the thread is about to exit. (except in the
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> cases where the thread group is no longer going to be used - in which
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> case, it's fine for there to be invalid workers in the thread group).
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    if (!shutdown_complete &amp;&amp; !outer()-&gt;join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      DCHECK(!outer()-&gt;idle_workers_set_</span></span><span class="diff-removed">.</span><span class="diff-removed"><span class="diff-refine-removed">Contains</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">))</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // |worker| should already have been removed from |workers_| by the time the
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> thread is about to exit. (except in the cases where the thread group is
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> no longer going to be used - in which case, it's fine for there to be
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> invalid workers in the thread group).
</span><span class="diff-indicator-added">+</span><span class="diff-added">    if (!shutdown_complete &amp;&amp; !outer()-&gt;join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_.</span><span class="diff-added"><span class="diff-refine-added">IsSet</span></span><span class="diff-added">()) </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">
</span><span class="diff-context">       DCHECK(!ContainsWorker(outer()-&gt;workers_, worker));
     }
   }
</span><span class="diff-hunk-header">@@ -267,7 +195,15 @@</span>
<span class="diff-context">   // of cleaning up happen outside the lock (e.g. recording histograms) and
   // resuming from tests must happen-after that point or checks on the main
   // thread will be flaky (crbug.com/1047733).
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreScopedCommandsExecutor executor(outer());
</span><span class="diff-context">   CheckedAutoLock auto_lock(outer()-&gt;lock_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  AnnotateAcquiredLockAlias alias(outer()-&gt;lock_, executor.outer()-&gt;lock_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // This is required for joining all workers in order to not cause a hang as
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // PlatformThread::Join() is called on only one thread at a time while any
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // thread at all may be woken up by the semaphore and exit.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (join_called_for_testing_-&gt;IsSet()) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    executor.ScheduleSignal();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-context">   ++outer()-&gt;num_workers_cleaned_up_for_testing_;
 #if DCHECK_IS_ON()
   outer()-&gt;some_workers_cleaned_up_for_testing_ = true;
</span><span class="diff-hunk-header">@@ -277,54 +213,51 @@</span>
<span class="diff-context">   }
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::CanGetWorkLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">bool ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::CanGetWorkLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* executor,
     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker_base</span><span class="diff-removed"><span class="diff-refine-removed">);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  const bool is_on_idle_workers_set = outer()-&gt;IsOnIdleSetLockRequired(worker);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_EQ(is_on_idle_workers_set,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">            outer()-&gt;idle_workers_set_.Contains(worker)</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context"> 
   AnnotateAcquiredLockAlias annotate(outer()-&gt;lock_, lock());
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // </span><span class="diff-removed"><span class="diff-refine-removed">This occurs</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">when</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">the</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">when</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">WorkerThread::Delegate::</span></span><span class="diff-removed">Wait</span><span class="diff-removed"><span class="diff-refine-removed">ForWork</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">times out
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // (i.e. when the worker's wakes up after GetSleepTimeout())</span></span><span class="diff-removed">.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (</span><span class="diff-removed"><span class="diff-refine-removed">is_on_idle</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // </span><span class="diff-added"><span class="diff-refine-added">|timed_out_|</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">is</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">set</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">by</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">Timed</span></span><span class="diff-added">Wait().
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (</span><span class="diff-added"><span class="diff-refine-added">timed</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">out</span></span><span class="diff-added">_) {
</span><span class="diff-context">     if (CanCleanupLockRequired(worker)) {
       CleanupLockRequired(executor, worker);
     }
     return false;
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // If too many workers are </span><span class="diff-removed"><span class="diff-refine-removed">running</span></span><span class="diff-removed">, this worker should not get work, until
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  //</span></span><span class="diff-removed"> tasks are no longer in excess (i.e. max tasks increases). </span><span class="diff-removed"><span class="diff-refine-removed">This ensures that
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // if this worker is in excess, it gets a chance to being cleaned up.</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">GetNumAwakeWorkersLockRequired(</span></span><span class="diff-removed">) &gt; outer()-&gt;max_tasks_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // If too many workers are </span><span class="diff-added"><span class="diff-refine-added">currently awake (contrasted with ThreadGroupImpl
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // where this decision is made by the number of workers which were signaled)</span></span><span class="diff-added">,
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  //</span></span><span class="diff-added"> this worker should not get work, until tasks are no longer in excess
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  //</span></span><span class="diff-added"> (i.e. max tasks increases).
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (</span><span class="diff-added"><span class="diff-refine-added">static_cast&lt;size_t&gt;(</span></span><span class="diff-added">outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num_active_signals_</span></span><span class="diff-added">) &gt; outer()-&gt;max_tasks_) {
</span><span class="diff-context">     OnWorkerBecomesIdleLockRequired(executor, worker);
     return false;
   }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context">   return true;
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">RegisteredTaskSource ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::GetWork(
</span><span class="diff-indicator-added">+</span><span class="diff-added">RegisteredTaskSource ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::GetWork(
</span><span class="diff-context">     WorkerThread* worker_base) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
   DCHECK(!read_worker().current_task_priority);
   DCHECK(!read_worker().current_shutdown_behavior);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(outer());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(outer());
</span><span class="diff-context">   CheckedAutoLock auto_lock(outer()-&gt;lock_);
   AnnotateAcquiredLockAlias alias(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      outer()-&gt;lock_, static_cast&lt;ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">*&gt;(outer_.get())-&gt;lock_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">      outer()-&gt;lock_, static_cast&lt;ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(outer_.get())-&gt;lock_);
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">
</span><span class="diff-context">   return GetWorkLockRequired(&amp;executor, worker);
 }
 
 RegisteredTaskSource
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::SwapProcessedTask(
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::SwapProcessedTask(
</span><span class="diff-context">     RegisteredTaskSource task_source,
     WorkerThread* worker) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-hunk-header">@@ -342,14 +275,7 @@</span>
<span class="diff-context">             std::move(task_source)));
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">// Calling WakeUp() guarantees that this WorkerThread will run Tasks from
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // TaskSources returned by the GetWork() method of |delegate_| until it
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // returns nullptr. Resetting |wake_up_event_| here doesn't break this
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // invariant and avoids a useless loop iteration before going to sleep if
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // WakeUp() is called while this WorkerThread is awake.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  wake_up_event_.Reset();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  ScopedCommandsExecutor workers_executor(outer());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor workers_executor(outer());
</span><span class="diff-context">   ScopedReenqueueExecutor reenqueue_executor;
   CheckedAutoLock auto_lock(outer()-&gt;lock_);
   AnnotateAcquiredLockAlias annotate(outer()-&gt;lock_, lock());
</span><span class="diff-hunk-header">@@ -378,83 +304,100 @@</span>
<span class="diff-context">   write_worker().current_task_priority = absl::nullopt;
 
   if (transaction_with_task_source) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // If there is a task to enqueue, we can swap it for another task without
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // changing DesiredNumAwakeWorkers(), and thus without worrying about
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // signaling/waiting.
</span><span class="diff-context">     outer()-&gt;ReEnqueueTaskSourceLockRequired(
         &amp;workers_executor, &amp;reenqueue_executor,
         std::move(transaction_with_task_source.value()));
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return GetWorkLockRequired(&amp;workers_executor,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                             static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker));
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return GetWorkLockRequired(&amp;workers_executor,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                               static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore*&gt;(worker));
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  } else if (outer()-&gt;GetDesiredNumAwakeWorkersLockRequired() &gt;=
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">             static_cast&lt;size_t&gt;(outer()-&gt;num_active_signals_)) {
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    // When the thread pool wants more work to be run but hasn't signaled
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    // workers for it yet we can take advantage and grab more work without
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    // signal/wait contention.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    return GetWorkLockRequired(&amp;workers_executor,
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">                               static_cast&lt;WorkerThreadSemaphore</span></span><span class="diff-added">*&gt;(worker))</span><span class="diff-added"><span class="diff-refine-added">;
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  }
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // In the case where the worker does not have a task source to exchange and
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // the thread group doesn't want more work than the number of workers awake,
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // it must WaitForWork(), to keep |num_active_signals| synchronized with the
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // number of desired awake workers.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  OnWorkerBecomesIdleLockRequired(&amp;workers_executor, worker);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  return nullptr</span></span><span class="diff-added">;
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">bool</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::</span><span class="diff-removed"><span class="diff-refine-removed">IsExcess</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">const</span></span><span class="diff-removed"> {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return </span><span class="diff-removed"><span class="diff-refine-removed">is_excess_</span></span><span class="diff-removed">;
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">TimeDelta</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::</span><span class="diff-added"><span class="diff-refine-added">GetSleepTimeout</span></span><span class="diff-added">() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return </span><span class="diff-added"><span class="diff-refine-added">ThreadPoolSleepTimeout()</span></span><span class="diff-added">;
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::</span><span class="diff-removed"><span class="diff-refine-removed">CanCleanupLockRequired</span></span><span class="diff-removed">(
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">    const </span><span class="diff-removed"><span class="diff-refine-removed">WorkerThread* worker)</span></span><span class="diff-removed"> {
</span><span class="diff-indicator-added">+</span><span class="diff-added">bool ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::</span><span class="diff-added"><span class="diff-refine-added">IsExcess</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">)</span></span><span class="diff-added"> const {
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (!IsExcess()) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return false;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">const</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">TimeTicks</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">last_used_time</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">=</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">worker-&gt;GetLastUsedTime();</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">!last_used_time.</span></span><span class="diff-removed">is</span><span class="diff-removed"><span class="diff-refine-removed">_null()</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&amp;&amp;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">         </span><span class="diff-removed"><span class="diff-refine-removed">subtle::TimeTicksNowIgnoringOverride()</span></span><span class="diff-removed"> - </span><span class="diff-removed"><span class="diff-refine-removed">last_used_time</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&gt;=</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">             outer()-&gt;after_start().</span><span class="diff-removed"><span class="diff-refine-removed">suggested</span></span><span class="diff-removed">_reclaim</span><span class="diff-removed"><span class="diff-refine-removed">_time</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&amp;&amp;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">         </span><span class="diff-removed"><span class="diff-refine-removed">LIKELY(!</span></span><span class="diff-removed">outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">cleanup</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">disallowed</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">for</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">testing</span></span><span class="diff-removed">_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">Contrasted</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">to</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">ThreadGroupImpl,</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">where its workers residing somewhere in the</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">// stack</span></span><span class="diff-added"> is </span><span class="diff-added"><span class="diff-refine-added">either</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">excess</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">or</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">not</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">-</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">all</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">workers</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">in</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">this</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">group</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">can be in</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">excess.</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">What</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">is</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">important</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">is</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">whether</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">there</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">are</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">currently more workers than
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // this group's</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">initial max tasks.</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">return</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">!</span></span><span class="diff-added">outer()-&gt;after_start().</span><span class="diff-added"><span class="diff-refine-added">no_worker</span></span><span class="diff-added">_reclaim </span><span class="diff-added"><span class="diff-refine-added">||</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">         outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">workers</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">in</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">excess</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">.load(std::memory_order</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">acquire</span></span><span class="diff-added">);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::CleanupLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">bool ThreadGroupSemaphore::SemaphoreWorkerDelegate::CanCleanupLockRequired(
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    const WorkerThread* worker) {
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  return IsExcess() &amp;&amp; LIKELY(!outer()-&gt;worker_cleanup_disallowed_for_testing_);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">}
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::CleanupLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* executor,
     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  DCHECK(!outer()-&gt;join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(!outer()-&gt;join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_</span><span class="diff-added"><span class="diff-refine-added">.IsSet()</span></span><span class="diff-added">);
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  worker</span><span class="diff-removed"><span class="diff-refine-removed">-&gt;Cleanup();</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">if</span></span><span class="diff-removed"> (outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">IsOnIdleSetLockRequired</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">)) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">idle</span></span><span class="diff-removed">_workers_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_.</span><span class="diff-removed"><span class="diff-refine-removed">Remove</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">if (outer()-&gt;after_start().no_</span></span><span class="diff-added">worker</span><span class="diff-added"><span class="diff-refine-added">_reclaim</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">&amp;&amp;</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">outer()-&gt;workers_.size</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">) &gt;</span></span><span class="diff-added"> outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">after_start</span></span><span class="diff-added">()</span><span class="diff-added"><span class="diff-refine-added">.initial_max_tasks</span></span><span class="diff-added">) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_workers_</span><span class="diff-added"><span class="diff-refine-added">in_excess</span></span><span class="diff-added">_.</span><span class="diff-added"><span class="diff-refine-added">fetch_sub</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">1, std::memory_order_acq_rel</span></span><span class="diff-added">);
</span><span class="diff-context">   }
 
</span><span class="diff-indicator-added">+</span><span class="diff-added">  worker-&gt;Cleanup();
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context">   // Remove the worker from |workers_|.
   auto worker_iter = ranges::find(outer()-&gt;workers_, worker);
   DCHECK(worker_iter != outer()-&gt;workers_.end());
   outer()-&gt;workers_.erase(worker_iter);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::
</span><span class="diff-context">     OnWorkerBecomesIdleLockRequired(BaseScopedCommandsExecutor* executor,
                                     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThreadWaitableEvent* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThreadWaitableEvent*&gt;(worker_base);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK(!</span></span><span class="diff-removed">outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">idle</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Contains(worker))</span></span><span class="diff-removed">;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // Add the worker to the idle set.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  outer()-&gt;idle_workers_set_</span><span class="diff-removed"><span class="diff-refine-removed">.Insert(worker);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_LE(outer()-&gt;idle</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Size(), outer()</span></span><span class="diff-removed">-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">workers_.size</span></span><span class="diff-removed">()</span><span class="diff-removed"><span class="diff-refine-removed">)</span></span><span class="diff-removed">;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">idle_workers_set_cv</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">for</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">testing</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">-&gt;Broadcast(</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">--</span></span><span class="diff-added">outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">active</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals</span></span><span class="diff-added">_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  outer()-&gt;idle_workers_set_</span><span class="diff-added"><span class="diff-refine-added">cv</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">for</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">testing</span></span><span class="diff-added">_-&gt;</span><span class="diff-added"><span class="diff-refine-added">Signal</span></span><span class="diff-added">();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">CHECK_GE(</span></span><span class="diff-added">outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">active</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">, 0</span></span><span class="diff-added">);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::RecordUnnecessaryWakeup() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::RecordUnnecessaryWakeup() {
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
   RecordUnnecessaryWakeupImpl();
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::JoinForTesting() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::JoinForTesting() {
</span><span class="diff-context">   decltype(workers_) workers_copy;
   {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    SemaphoreScopedCommandsExecutor executor(this);
</span><span class="diff-context">     CheckedAutoLock auto_lock(lock_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">    AnnotateAcquiredLockAlias alias(lock_, executor.outer()-&gt;lock_);
</span><span class="diff-context">     priority_queue_.EnableFlushTaskSourcesOnDestroyForTesting();
 
     DCHECK_GT(workers_.size(), size_t(0))
         &lt;&lt; "Joined an unstarted thread group.";
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_ = true</span></span><span class="diff-removed">;
</span><span class="diff-indicator-added">+</span><span class="diff-added">    join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_</span><span class="diff-added"><span class="diff-refine-added">.Set()</span></span><span class="diff-added">;
</span><span class="diff-context"> 
     // Ensure WorkerThreads in |workers_| do not attempt to cleanup while
     // being joined.
</span><span class="diff-hunk-header">@@ -464,9 +407,14 @@</span>
<span class="diff-context">     // WorkerThread::JoinForTesting() without holding |lock_| since
     // WorkerThreads may need to access |workers_|.
     workers_copy = workers_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // The semaphore is signaled in JoinForTesting.
</span><span class="diff-indicator-added">+</span><span class="diff-added">    num_active_signals_ += workers_copy.size();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    executor.ScheduleSignal();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    join_called_for_testing_.Set();
</span><span class="diff-context">   }
   for (const auto&amp; worker : workers_copy) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker.get())-&gt;JoinForTesting();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker.get())-&gt;JoinForTesting();
</span><span class="diff-context">   }
 
   CheckedAutoLock auto_lock(lock_);
</span><span class="diff-hunk-header">@@ -475,96 +423,51 @@</span>
<span class="diff-context">   workers_.clear();
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">size_t ThreadGroupImpl::NumberOfWorkersForTesting() const {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  CheckedAutoLock auto_lock(lock_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  return workers_.size();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">size_t ThreadGroupImpl::NumberOfIdleWorkersForTesting() const {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  CheckedAutoLock auto_lock(lock_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  return NumberOfIdleWorkersLockRequiredForTesting();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">size_t ThreadGroupImpl::NumberOfIdleWorkersLockRequiredForTesting() const {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  return idle_workers_set_.Size();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">MaintainAtLeastOneIdle</span></span><span class="diff-removed">WorkerLockRequired(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    ScopedCommandsExecutor* executor) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">CreateAndRegister</span></span><span class="diff-added">WorkerLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor* executor) {
</span><span class="diff-context">   if (workers_.size() == kMaxNumberOfWorkers) {
     return;
   }
   DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (!idle_workers_set_.IsEmpty()) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context">   if (workers_.size() &gt;= max_tasks_) {
     return;
   }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  scoped_refptr&lt;WorkerThreadWaitableEvent&gt; new_worker =
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      CreateAndRegisterWorkerLockRequired(executor);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK(new_worker);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  idle_workers_set_.Insert(new_worker.get());
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">scoped_refptr&lt;WorkerThreadWaitableEvent&gt;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">ThreadGroupImpl::CreateAndRegisterWorkerLockRequired(
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    ScopedCommandsExecutor* executor) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  DCHECK(!join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_LT(workers_.size(), max_tasks_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK(idle_workers_set_</span></span><span class="diff-removed">.Is</span><span class="diff-removed"><span class="diff-refine-removed">Empty</span></span><span class="diff-removed">());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(!join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_.Is</span><span class="diff-added"><span class="diff-refine-added">Set</span></span><span class="diff-added">());
</span><span class="diff-context"> 
   // WorkerThread needs |lock_| as a predecessor for its thread lock because in
   // GetWork(), |lock_| is first acquired and then the thread lock is acquired
   // when GetLastUsedTime() is called on the worker by CanGetWorkLockRequired().
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  scoped_refptr&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">&gt; worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      MakeRefCounted&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">&gt;(
</span><span class="diff-indicator-added">+</span><span class="diff-added">  scoped_refptr&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">&gt; worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      MakeRefCounted&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">&gt;(
</span><span class="diff-context">           thread_type_hint_,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">          std::make_unique&lt;</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">              tracked_ref_factory_.GetTrackedRef(),
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">              /* is_excess=*/after_start().no_worker_reclaim
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                  ? workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.size() &gt;= after</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">start().initial</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">max</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">tasks
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                  : true</span></span><span class="diff-removed">),
</span><span class="diff-indicator-added">+</span><span class="diff-added">          std::make_unique&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate&gt;(
</span><span class="diff-indicator-added">+</span><span class="diff-added">              tracked_ref_factory_.GetTrackedRef(), </span><span class="diff-added"><span class="diff-refine-added">&amp;join</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">called</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">for</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">testing</span></span><span class="diff-added">_),
</span><span class="diff-context">           task_tracker_, worker_sequence_num_++, &amp;lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">DCHECK(worker);</span></span><span class="diff-added">
</span><span class="diff-context">   workers_.push_back(worker);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  executor-&gt;ScheduleStart(worker);
</span><span class="diff-context">   DCHECK_LE(workers_.size(), max_tasks_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> worker</span><span class="diff-removed"><span class="diff-refine-removed">;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">size</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">t ThreadGroupImpl::GetNumAwakeWorkersLockRequired() const</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">{</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK_GE(workers_.size(), idle_workers_set_.Size());
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">size_t</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">num_awake_workers</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">=</span></span><span class="diff-removed"> workers_.size() </span><span class="diff-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">idle_workers_set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Size</span></span><span class="diff-removed">()</span><span class="diff-removed"><span class="diff-refine-removed">;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_GE(num_awake_workers, num</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">running</span></span><span class="diff-removed">_tasks</span><span class="diff-removed"><span class="diff-refine-removed">_</span></span><span class="diff-removed">)</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> num_</span><span class="diff-removed"><span class="diff-refine-removed">awake_</span></span><span class="diff-removed">workers</span><span class="diff-removed"><span class="diff-refine-removed">;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">void ThreadGroupImpl::DidUpdateCanRunPolicy</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  std::</span><span class="diff-removed"><span class="diff-refine-removed">unique</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">ptr&lt;BaseScopedCommandsExecutor&gt; executor = GetExecutor(</span></span><span class="diff-removed">);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">CheckedAutoLock auto_lock(lock_);</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">EnsureEnoughWorkersLockRequired(</span></span><span class="diff-removed">executor</span><span class="diff-removed"><span class="diff-refine-removed">.get</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">)</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">if</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">(after_start().no_</span></span><span class="diff-added">worker_</span><span class="diff-added"><span class="diff-refine-added">reclaim</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">&amp;&amp;</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      workers_.size() </span><span class="diff-added"><span class="diff-refine-added">&gt;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">after</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">start</span></span><span class="diff-added">()</span><span class="diff-added"><span class="diff-refine-added">.initial</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">max</span></span><span class="diff-added">_tasks) </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    num_workers</span><span class="diff-added"><span class="diff-refine-added">_in_excess_.fetch_add</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">1,</span></span><span class="diff-added"> std::</span><span class="diff-added"><span class="diff-refine-added">memory</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">order_acq_rel</span></span><span class="diff-added">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">}</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  executor</span><span class="diff-added"><span class="diff-refine-added">-&gt;ScheduleStart</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">worker</span></span><span class="diff-added">);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::OnShutdownStarted() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::OnShutdownStarted() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
 
   // Don't do anything if the thread group isn't started.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (max_tasks_ == 0 || UNLIKELY(join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_</span></span><span class="diff-removed">)) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (max_tasks_ == 0 || UNLIKELY(join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_</span><span class="diff-added"><span class="diff-refine-added">.IsSet()</span></span><span class="diff-added">)) {
</span><span class="diff-context">     return;
   }
 
   // Start a MAY_BLOCK scope on each worker that is already running a task.
   for (scoped_refptr&lt;WorkerThread&gt;&amp; worker : workers_) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // The delegates of workers inside a ThreadGroup should be
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // Worker</span><span class="diff-removed"><span class="diff-refine-removed">ThreadDelegateImpls</span></span><span class="diff-removed">.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate* delegate =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">        static_cast&lt;</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate*&gt;(worker-&gt;delegate());
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // The delegates of workers inside a ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added"> should be
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">Worker</span><span class="diff-added"><span class="diff-refine-added">Delegates</span></span><span class="diff-added">.
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate* delegate =
</span><span class="diff-indicator-added">+</span><span class="diff-added">        static_cast&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate*&gt;(worker-&gt;delegate());
</span><span class="diff-context">     AnnotateAcquiredLockAlias annotate(lock_, delegate-&gt;lock());
     delegate-&gt;OnShutdownStartedLockRequired(&amp;executor);
   }
</span><span class="diff-hunk-header">@@ -573,38 +476,32 @@</span>
<span class="diff-context">   shutdown_started_ = true;
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::EnsureEnoughWorkersLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::EnsureEnoughWorkersLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* base_executor) {
   // Don't do anything if the thread group isn't started.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (max_tasks_ == 0 || UNLIKELY(join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_</span></span><span class="diff-removed">)) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (max_tasks_ == 0 || UNLIKELY(join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_</span><span class="diff-added"><span class="diff-refine-added">.IsSet()</span></span><span class="diff-added">)) {
</span><span class="diff-context">     return;
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor* executor =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;ScopedCommandsExecutor*&gt;(base_executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor* executor =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor*&gt;(base_executor);
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const size_t desired_</span><span class="diff-removed"><span class="diff-refine-removed">num_</span></span><span class="diff-removed">awake_workers =
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">      GetDesiredNumAwakeWorkersLockRequired();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const size_t num_</span><span class="diff-removed"><span class="diff-refine-removed">awake_</span></span><span class="diff-removed">workers = </span><span class="diff-removed"><span class="diff-refine-removed">GetNumAwakeWorkersLockRequired();</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  size_t num_workers_</span><span class="diff-removed"><span class="diff-refine-removed">to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wake</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">up =</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      ClampSub(desired_</span><span class="diff-removed"><span class="diff-refine-removed">num_awake_workers, num_</span></span><span class="diff-removed">awake_workers</span><span class="diff-removed"><span class="diff-refine-removed">);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">num_workers_to_wake_up</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">=</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">std::min(num_</span></span><span class="diff-removed">workers_</span><span class="diff-removed"><span class="diff-refine-removed">to_wake_up,</span></span><span class="diff-removed"> size</span><span class="diff-removed"><span class="diff-refine-removed">_t</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">2U</span></span><span class="diff-removed">));
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // Wake up the appropriate number of workers.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  for (size_t i = 0; i &lt; num_workers_to_</span><span class="diff-removed"><span class="diff-refine-removed">wake_up</span></span><span class="diff-removed">; ++i) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">MaintainAtLeastOneIdle</span></span><span class="diff-removed">WorkerLockRequired(executor);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">WorkerThreadWaitableEvent*</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wakeup</span></span><span class="diff-removed"> = </span><span class="diff-removed"><span class="diff-refine-removed">idle</span></span><span class="diff-removed">_workers_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Take(</span></span><span class="diff-removed">);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker_to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wakeup);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">    executor-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">ScheduleWakeUp</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker_to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wakeup</span></span><span class="diff-removed">);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // In the case where the loop above didn't wake up any worker and we don't
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // have excess workers, the idle worker should be maintained. This happens
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // when called from the last worker awake, or a recent increase in</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">|max</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">tasks|
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // now makes it possible to keep an</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">idle</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">worker.</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">if</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">(desired_num_awake</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers ==</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">num_awake_workers</span></span><span class="diff-removed">) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">MaintainAtLeastOneIdleWorkerLockRequired(</span></span><span class="diff-removed">executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  const size_t desired_awake_workers = GetDesiredNumAwakeWorkersLockRequired();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">// The +1 here is due to the fact that we always want there to be one idle
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // worker.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  const size_t num_workers</span><span class="diff-added"><span class="diff-refine-added">_to_create</span></span><span class="diff-added"> =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">std::min({static_cast&lt;</span></span><span class="diff-added">size_t</span><span class="diff-added"><span class="diff-refine-added">&gt;(after_start().max_</span></span><span class="diff-added">num_workers_</span><span class="diff-added"><span class="diff-refine-added">created),
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">                static</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">cast&lt;size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t&gt;(</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">                    ClampSub(desired_awake_workers </span><span class="diff-added"><span class="diff-refine-added">+</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">1,</span></span><span class="diff-added"> workers_</span><span class="diff-added"><span class="diff-refine-added">.</span></span><span class="diff-added">size())</span><span class="diff-added"><span class="diff-refine-added">)})</span></span><span class="diff-added">;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  for (size_t i = 0; i &lt; num_workers_to_</span><span class="diff-added"><span class="diff-refine-added">create</span></span><span class="diff-added">; ++i) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">CreateAndRegister</span></span><span class="diff-added">WorkerLockRequired(executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">}</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">const size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t new</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals</span></span><span class="diff-added"> =
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">      ClampSub(desired_awake</span></span><span class="diff-added">_workers</span><span class="diff-added"><span class="diff-refine-added">, num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">active_signals</span></span><span class="diff-added">_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">AnnotateAcquiredLockAlias</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">alias</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">lock</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">,</span></span><span class="diff-added"> executor-&gt;</span><span class="diff-added"><span class="diff-refine-added">outer</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">)-&gt;lock</span></span><span class="diff-added">_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">for</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">(size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">i</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">=</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">0;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">i</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">&lt;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">new</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">++i</span></span><span class="diff-added">) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    executor</span><span class="diff-added"><span class="diff-refine-added">-&gt;ScheduleSignal(</span></span><span class="diff-added">);
</span><span class="diff-context">   }
 
   // This function is called every time a task source is (re-)enqueued,
</span><span class="diff-hunk-header">@@ -615,40 +512,5 @@</span>
<span class="diff-context">   MaybeScheduleAdjustMaxTasksLockRequired(executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroupImpl::AdjustMaxTasks() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  DCHECK(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      after_start().service_thread_task_runner-&gt;RunsTasksInCurrentSequence());
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  std::unique_ptr&lt;BaseScopedCommandsExecutor&gt; executor = GetExecutor();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  CheckedAutoLock auto_lock(lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  DCHECK(adjust_max_tasks_posted_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  adjust_max_tasks_posted_ = false;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // Increment max tasks for each worker that has been within a MAY_BLOCK
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // ScopedBlockingCall for more than may_block_threshold.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  for (scoped_refptr&lt;WorkerThread&gt; worker : workers_) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // The delegates of workers inside a ThreadGroup should be
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // WaitableEventWorkerDelegates.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    ThreadGroupWorkerDelegate* delegate =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">        static_cast&lt;ThreadGroupWorkerDelegate*&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">            static_cast&lt;WaitableEventWorkerDelegate*&gt;(worker-&gt;delegate()));
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    AnnotateAcquiredLockAlias annotate(lock_, delegate-&gt;lock());
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    delegate-&gt;MaybeIncrementMaxTasksLockRequired();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // Wake up workers according to the updated |max_tasks_|. This will also
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // reschedule AdjustMaxTasks() if necessary.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  EnsureEnoughWorkersLockRequired(executor.get());
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">}
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroupImpl::IsOnIdleSetLockRequired(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    WorkerThreadWaitableEvent* worker) const {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // To avoid searching through the idle set : use GetLastUsedTime() not being
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // null (or being directly on top of the idle set) as a proxy for being on
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // the idle set.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return idle_workers_set_.Peek() == worker ||
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">         !worker-&gt;GetLastUsedTime().is_null();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">}
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context"> }  // namespace internal
 }  // namespace base

Diff finished.  Tue Jan 16 21:49:12 2024
</span></pre>
  </body>
</html>
