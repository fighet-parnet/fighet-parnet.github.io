<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.57 in css mode. -->
<html>
  <head>
    <title>*Diff*</title>
    <style type="text/css">
    <!--
      body {
        color: #c7c9cb;
        background-color: #232530;
      }
      .diff-added {
        /* diff-added */
        color: #09f7a0;
        background-color: #1c1e26;
      }
      .diff-context {
        /* diff-context */
        color: #afb0b2;
      }
      .diff-file-header {
        /* diff-file-header */
        color: #21bfc2;
      }
      .diff-header {
        /* diff-header */
        color: #59e3e3;
      }
      .diff-hunk-header {
        /* diff-hunk-header */
        color: #b877db;
      }
      .diff-indicator-added {
        /* diff-indicator-added */
        color: #22aa22;
        background-color: #1c1e26;
      }
      .diff-indicator-removed {
        /* diff-indicator-removed */
        color: #aa2222;
        background-color: #232530;
      }
      .diff-refine-added {
        /* diff-refine-added */
        color: #09f7a0;
        background-color: #1c1e26;
      }
      .diff-refine-removed {
        /* diff-refine-removed */
        color: #e95678;
        background-color: #232530;
      }
      .diff-removed {
        /* diff-removed */
        color: #e95678;
        background-color: #232530;
      }
      .hl-line {
        /* hl-line */
        background-color: #1c1e26;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="diff-header">diff -u --label \#\&lt;buffer\ thread_group_semaphore.cc\&gt; --label \#\&lt;buffer\ thread_group_impl.cc\&gt; /tmp/buffer-content-fsXWO6 /tmp/buffer-content-KIX27t
</span><span class="diff-header"><span class="hl-line">--- </span></span><span class="diff-header"><span class="diff-file-header"><span class="hl-line">#&lt;buffer thread_group_semaphore.cc&gt;</span></span></span><span class="diff-header"><span class="hl-line">
</span></span><span class="diff-header">+++ </span><span class="diff-header"><span class="diff-file-header">#&lt;buffer thread_group_impl.cc&gt;</span></span><span class="diff-header">
</span><span class="diff-hunk-header">@@ -1,99 +1,94 @@</span>
<span class="diff-indicator-removed">-</span><span class="diff-removed">// Copyright 2024 The Chromium Authors
</span><span class="diff-indicator-added">+</span><span class="diff-added">// Copyright 2016 The Chromium Authors
</span><span class="diff-context"> // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/thread_group_semaphore.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/debug/stack_trace.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include &lt;algorithm&gt;
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/thread_group_impl.h"
</span><span class="diff-context"> 
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/auto_reset.h"
</span><span class="diff-context"> #include "base/metrics/histogram_macros.h"
 #include "base/sequence_token.h"
 #include "base/strings/string_piece.h"
 #include "base/strings/stringprintf.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/common/checked_lock.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/thread_group.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/worker_thread_semaphore.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/thread_group_worker_delegate.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/worker_thread_waitable_event.h"
</span><span class="diff-context"> #include "base/threading/scoped_blocking_call.h"
 #include "base/threading/scoped_blocking_call_internal.h"
 #include "base/threading/thread_checker.h"
 #include "base/time/time_override.h"
 #include "base/trace_event/base_tracing.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "third_party/abseil-cpp/absl/container/inlined_vector.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "third_party/abseil-cpp/absl/types/optional.h"
</span><span class="diff-context"> 
 namespace base {
 namespace internal {
 
 namespace {
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context"> constexpr size_t kMaxNumberOfWorkers = 256;
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context"> }  // namespace
 
 // Upon destruction, executes actions that control the number of active workers.
 // Useful to satisfy locking requirements of these actions.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">class ThreadGroupSemaphore::SemaphoreScopedCommandsExecutor
</span><span class="diff-indicator-added">+</span><span class="diff-added">class ThreadGroupImpl::ScopedCommandsExecutor
</span><span class="diff-context">     : public ThreadGroup::BaseScopedCommandsExecutor {
  public:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  explicit SemaphoreScopedCommandsExecutor(ThreadGroupSemaphore* outer)
</span><span class="diff-indicator-added">+</span><span class="diff-added">  explicit ScopedCommandsExecutor(ThreadGroupImpl* outer)
</span><span class="diff-context">       : BaseScopedCommandsExecutor(outer) {}
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  SemaphoreScopedCommandsExecutor(const SemaphoreScopedCommandsExecutor&amp;) =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  SemaphoreScopedCommandsExecutor&amp; operator=(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      const SemaphoreScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ~SemaphoreScopedCommandsExecutor() override {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor(const ScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor&amp; operator=(const ScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ~ScopedCommandsExecutor() override {
</span><span class="diff-context">     CheckedLock::AssertNoLockHeldOnCurrentThread();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    for (int i = 0; i &lt; semaphore_signal_count_; ++i) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      outer()-&gt;semaphore_.Signal();
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // Wake up workers.
</span><span class="diff-indicator-added">+</span><span class="diff-added">    for (auto worker : workers_to_wake_up_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      worker-&gt;WakeUp();
</span><span class="diff-context">     }
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  void ScheduleSignal() EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    ++semaphore_signal_count_;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    ++outer()-&gt;num_active_signals_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  void ScheduleWakeUp(scoped_refptr&lt;WorkerThreadWaitableEvent&gt; worker) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    workers_to_wake_up_.emplace_back(std::move(worker));
</span><span class="diff-context">   }
 
  private:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  friend class ThreadGroupSemaphore;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ThreadGroupSemaphore* outer() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  int semaphore_signal_count_ = 0;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  absl::InlinedVector&lt;scoped_refptr&lt;WorkerThreadWaitableEvent&gt;, 2&gt;
</span><span class="diff-indicator-added">+</span><span class="diff-added">      workers_to_wake_up_;
</span><span class="diff-context"> };
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">class ThreadGroupSemaphore::SemaphoreWorkerDelegate
</span><span class="diff-indicator-added">+</span><span class="diff-added">class ThreadGroupImpl::WaitableEventWorkerDelegate
</span><span class="diff-context">     : public ThreadGroup::ThreadGroupWorkerDelegate,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      public WorkerThreadSemaphore::Delegate {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      public WorkerThreadWaitableEvent::Delegate {
</span><span class="diff-context">  public:
   // |outer| owns the worker for which this delegate is constructed. If
   // |is_excess| is true, this worker will be eligible for reclaim.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  explicit SemaphoreWorkerDelegate(TrackedRef&lt;ThreadGroup&gt; outer,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                   AtomicFlag* join_called_for_testing);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  SemaphoreWorkerDelegate(const SemaphoreWorkerDelegate&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  SemaphoreWorkerDelegate&amp; operator=(const SemaphoreWorkerDelegate&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  explicit WaitableEventWorkerDelegate(TrackedRef&lt;ThreadGroup&gt; outer,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                       bool is_excess);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WaitableEventWorkerDelegate(const WaitableEventWorkerDelegate&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WaitableEventWorkerDelegate&amp; operator=(const WaitableEventWorkerDelegate&amp;) =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      delete;
</span><span class="diff-context"> 
   // OnMainExit() handles the thread-affine cleanup;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // SemaphoreWorkerDelegate can thereafter safely be deleted from any thread.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ~SemaphoreWorkerDelegate() override = default;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // WaitableEventWorkerDelegate can thereafter safely be deleted from any
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // thread.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ~WaitableEventWorkerDelegate() override = default;
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // WorkerThread::Delegate:
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // ThreadGroup::Delegate:
</span><span class="diff-context">   void OnMainEntry(WorkerThread* worker) override;
   void OnMainExit(WorkerThread* worker) override;
   RegisteredTaskSource GetWork(WorkerThread* worker) override;
   RegisteredTaskSource SwapProcessedTask(RegisteredTaskSource task_source,
                                          WorkerThread* worker) override;
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // WorkerThreadWaitableEvent::Delegate:
</span><span class="diff-context">   void RecordUnnecessaryWakeup() override;
   // True if the calling worker is be eligible for reclaim.
   bool IsExcess() const override;
   TimeDelta GetSleepTimeout() override;
 
  private:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ThreadGroupSemaphore* outer() const {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_.get());
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ThreadGroupSemaphore* outer() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_.get());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ThreadGroupImpl* outer() const {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return static_cast&lt;ThreadGroupImpl*&gt;(outer_.get());
</span><span class="diff-context">   }
 
   // ThreadGroup::ThreadGroupWorkerDelegate:
</span><span class="diff-hunk-header">@@ -107,38 +102,40 @@</span>
<span class="diff-context">                                        WorkerThread* worker)
       EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_) override;
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  RegisteredTaskSource GetWorkLockRequired(
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor* executor,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">* worker) EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  RegisteredTaskSource GetWorkLockRequired(ScopedCommandsExecutor* executor,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">* worker)
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">      EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_);
</span><span class="diff-context"> 
   // Returns true if |worker| is allowed to cleanup and remove itself from the
   // thread group. Called from GetWork() when no work is available.
   bool CanCleanupLockRequired(const WorkerThread* worker)
       EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_) override;
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  const bool is_excess_;
</span><span class="diff-context"> };
 
 std::unique_ptr&lt;ThreadGroup::BaseScopedCommandsExecutor&gt;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::GetExecutor() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::GetExecutor() {
</span><span class="diff-context">   return static_cast&lt;std::unique_ptr&lt;BaseScopedCommandsExecutor&gt;&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      std::make_unique&lt;</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor&gt;(this));
</span><span class="diff-indicator-added">+</span><span class="diff-added">      std::make_unique&lt;ScopedCommandsExecutor&gt;(this));
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">(StringPiece histogram_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                           StringPiece thread_group_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                           ThreadType thread_type_hint,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                           TrackedRef&lt;TaskTracker&gt; task_tracker,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                           TrackedRef&lt;Delegate&gt; delegate)
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">(StringPiece histogram_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                 StringPiece thread_group_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                 ThreadType thread_type_hint,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                 TrackedRef&lt;TaskTracker&gt; task_tracker,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                 TrackedRef&lt;Delegate&gt; delegate)
</span><span class="diff-context">     : ThreadGroup(histogram_label,
                   thread_group_label,
                   thread_type_hint,
                   std::move(task_tracker),
                   std::move(delegate)),
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      </span><span class="diff-removed"><span class="diff-refine-removed">worker_</span></span><span class="diff-removed">idle_cv_for_testing_(lock_.CreateConditionVariable()),
</span><span class="diff-indicator-added">+</span><span class="diff-added">      idle</span><span class="diff-added"><span class="diff-refine-added">_workers_set</span></span><span class="diff-added">_cv_for_testing_(lock_.CreateConditionVariable()),
</span><span class="diff-context">       tracked_ref_factory_(this) {
   DCHECK(!thread_group_label_.empty());
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::Start(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::Start(
</span><span class="diff-context">     size_t max_tasks,
     size_t max_best_effort_tasks,
     TimeDelta suggested_reclaim_time,
</span><span class="diff-hunk-header">@@ -159,13 +156,13 @@</span>
<span class="diff-context">     worker_started_for_testing_-&gt;declare_only_used_while_idle();
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
   DCHECK(workers_.empty());
   EnsureEnoughWorkersLockRequired(&amp;executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::~ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::~ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">() {
</span><span class="diff-context">   // ThreadGroup should only ever be deleted:
   //  1) In tests, after JoinForTesting().
   //  2) In production, iff initialization failed.
</span><span class="diff-hunk-header">@@ -173,28 +170,28 @@</span>
<span class="diff-context">   DCHECK(workers_.empty());
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::UpdateSortKey(TaskSource::Transaction transaction) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::UpdateSortKey(TaskSource::Transaction transaction) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   UpdateSortKeyImpl(&amp;executor, std::move(transaction));
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::PushTaskSourceAndWakeUpWorkers(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::PushTaskSourceAndWakeUpWorkers(
</span><span class="diff-context">     RegisteredTaskSourceAndTransaction transaction_with_task_source) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   PushTaskSourceAndWakeUpWorkersImpl(&amp;executor,
                                      std::move(transaction_with_task_source));
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::WaitForWorkersIdleLockRequiredForTesting(size_t n) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::WaitForWorkersIdleLockRequiredForTesting(size_t n) {
</span><span class="diff-context">   // Make sure workers do not cleanup while watching the idle count.
   AutoReset&lt;bool&gt; ban_cleanups(&amp;worker_cleanup_disallowed_for_testing_, true);
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  while (</span><span class="diff-removed"><span class="diff-refine-removed">NumberOfIdleWorkersLockRequiredForTesting</span></span><span class="diff-removed">() &lt; n) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">worker_</span></span><span class="diff-removed">idle_cv_for_testing_-&gt;Wait();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  while (</span><span class="diff-added"><span class="diff-refine-added">idle_workers_set_.Size</span></span><span class="diff-added">() &lt; n) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    idle</span><span class="diff-added"><span class="diff-refine-added">_workers_set</span></span><span class="diff-added">_cv_for_testing_-&gt;Wait();
</span><span class="diff-context">   }
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::WaitForWorkersIdleForTesting(size_t n) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::WaitForWorkersIdleForTesting(size_t n) {
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
 
 #if DCHECK_IS_ON()
</span><span class="diff-hunk-header">@@ -207,12 +204,12 @@</span>
<span class="diff-context">   WaitForWorkersIdleLockRequiredForTesting(n);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::WaitForAllWorkersIdleForTesting() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::WaitForAllWorkersIdleForTesting() {
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
   WaitForWorkersIdleLockRequiredForTesting(workers_.size());
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::WaitForWorkersCleanedUpForTesting(size_t n) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::WaitForWorkersCleanedUpForTesting(size_t n) {
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
 
   if (!num_workers_cleaned_up_for_testing_cv_) {
</span><span class="diff-hunk-header">@@ -226,33 +223,19 @@</span>
<span class="diff-context">   num_workers_cleaned_up_for_testing_ = 0;
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">size_t</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">NumberOfWorkersForTesting</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">)</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">const</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">{</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">CheckedAutoLock</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">auto_lock(lock_);</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.size(</span></span><span class="diff-removed">)</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">}</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">size_t</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">NumberOfIdleWorkersForTesting</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">const {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  CheckedAutoLock auto</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">lock(lock</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // Subtraction</span></span><span class="diff-removed"> is </span><span class="diff-removed"><span class="diff-refine-removed">clamped because the signal count of the semaphore can easily</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // </span><span class="diff-removed"><span class="diff-refine-removed">be higher than the number</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">of</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return NumberOfIdleWorkersLockRequiredForTesting</span></span><span class="diff-removed">();
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEventWorkerDelegate::WaitableEventWorkerDelegate</span></span><span class="diff-added">(
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">TrackedRef&lt;ThreadGroup&gt;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">outer,</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">bool is</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">excess</span></span><span class="diff-added">)
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">:</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">WorkerDelegate(std</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">move</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">outer</span></span><span class="diff-added">)</span><span class="diff-added"><span class="diff-refine-added">),</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">is</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">excess</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">(</span></span><span class="diff-added">is</span><span class="diff-added"><span class="diff-refine-added">_excess)</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // </span><span class="diff-added"><span class="diff-refine-added">Bound</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">in</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">OnMainEntry()</span></span><span class="diff-added">.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">DETACH_FROM_THREAD</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">worker_thread_checker_</span></span><span class="diff-added">);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">size_t</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">NumberOfIdleWorkersLockRequiredForTesting</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">const</span></span><span class="diff-removed"> {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return </span><span class="diff-removed"><span class="diff-refine-removed">std::max(
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      size_t(ClampSub(workers_.size(), max_tasks_)),
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      static_cast&lt;size_t&gt;(ClampSub(static_cast&lt;int64_t&gt;(workers_.size()),
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                                   static_cast&lt;int64_t&gt;</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">num_active_signals_)))</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">TimeDelta</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEventWorkerDelegate::GetSleepTimeout</span></span><span class="diff-added">() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return </span><span class="diff-added"><span class="diff-refine-added">ThreadPoolSleepTimeout</span></span><span class="diff-added">();
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">ThreadGroupSemaphore::SemaphoreWorkerDelegate::SemaphoreWorkerDelegate(
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    TrackedRef&lt;ThreadGroup&gt; outer,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    AtomicFlag* join_called_for_testing)
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    : ThreadGroupWorkerDelegate(std::move(outer)),
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      Delegate(&amp;static_cast&lt;ThreadGroupSemaphore*&gt;(outer.get())-&gt;semaphore_,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">               join_called_for_testing) {}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::OnMainEntry(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::OnMainEntry(
</span><span class="diff-context">     WorkerThread* worker) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
 
</span><span class="diff-hunk-header">@@ -269,8 +252,8 @@</span>
<span class="diff-context">       outer()-&gt;after_start().worker_environment);
 #endif  // BUILDFLAG(IS_WIN)
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  PlatformThread::SetName(StringPrintf("ThreadPool%s</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">Worker",
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">                                       outer()-&gt;thread_group_label_.c_str()));
</span><span class="diff-indicator-added">+</span><span class="diff-added">  PlatformThread::SetName(
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">      StringPrintf("ThreadPool%sWorker", outer()-&gt;thread_group_label_.c_str()));
</span><span class="diff-context"> 
   outer()-&gt;BindToCurrentThread();
   worker_only().worker_thread_ =
</span><span class="diff-hunk-header">@@ -286,22 +269,23 @@</span>
<span class="diff-context">   }
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::OnMainExit(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::OnMainExit(
</span><span class="diff-context">     WorkerThread* worker_base) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
 
 #if DCHECK_IS_ON()
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context">   {
     bool shutdown_complete = outer()-&gt;task_tracker_-&gt;IsShutdownComplete();
     CheckedAutoLock auto_lock(outer()-&gt;lock_);
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // |worker| should already have been removed from |workers_| by the time the
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> thread is about to exit. (except in the cases where the thread group is
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> no longer going to be used - in which case, it's fine for there to be
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> invalid workers in the thread group).
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // |worker| should already have been removed from </span><span class="diff-added"><span class="diff-refine-added">the idle workers set and
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> |workers_| by the time the thread is about to exit. (except in the
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> cases where the thread group is no longer going to be used - in which
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> case, it's fine for there to be invalid workers in the thread group).
</span><span class="diff-context">     if (!shutdown_complete &amp;&amp; !outer()-&gt;join_for_testing_started_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      DCHECK(!outer()-&gt;idle_workers_set_.Contains(worker));
</span><span class="diff-context">       DCHECK(!ContainsWorker(outer()-&gt;workers_, worker));
     }
   }
</span><span class="diff-hunk-header">@@ -316,15 +300,7 @@</span>
<span class="diff-context">   // of cleaning up happen outside the lock (e.g. recording histograms) and
   // resuming from tests must happen-after that point or checks on the main
   // thread will be flaky (crbug.com/1047733).
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  SemaphoreScopedCommandsExecutor executor(outer());
</span><span class="diff-context">   CheckedAutoLock auto_lock(outer()-&gt;lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  AnnotateAcquiredLockAlias alias(outer()-&gt;lock_, executor.outer()-&gt;lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // This is required for joining all workers in order to not cause a hang as
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // PlatformThread::Join() is called on only one thread at a time while any
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // thread at all may be woken up by the semaphore and exit.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (join_called_for_testing_-&gt;IsSet()) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    executor.ScheduleSignal();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-context">   ++outer()-&gt;num_workers_cleaned_up_for_testing_;
 #if DCHECK_IS_ON()
   outer()-&gt;some_workers_cleaned_up_for_testing_ = true;
</span><span class="diff-hunk-header">@@ -334,42 +310,46 @@</span>
<span class="diff-context">   }
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::CanGetWorkLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">bool ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::CanGetWorkLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* executor,
     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">*&gt;(worker_base</span><span class="diff-added"><span class="diff-refine-added">);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  const bool is_on_idle_workers_set = outer()-&gt;IsOnIdleSetLockRequired(worker);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  DCHECK_EQ(is_on_idle_workers_set,
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">            outer()-&gt;idle_workers_set_.Contains(worker)</span></span><span class="diff-added">);
</span><span class="diff-context"> 
   AnnotateAcquiredLockAlias annotate(outer()-&gt;lock_, lock());
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // </span><span class="diff-removed"><span class="diff-refine-removed">|timed_out_|</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">is</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">by</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">Timed</span></span><span class="diff-removed">Wait().
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (</span><span class="diff-removed"><span class="diff-refine-removed">timed</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">out</span></span><span class="diff-removed">_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // </span><span class="diff-added"><span class="diff-refine-added">This</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">occurs</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">when</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">the</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">when WorkerThread::Delegate::</span></span><span class="diff-added">Wait</span><span class="diff-added"><span class="diff-refine-added">ForWork</span></span><span class="diff-added">() </span><span class="diff-added"><span class="diff-refine-added">times out
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // (i.e. when the worker's wakes up after GetSleepTimeout())</span></span><span class="diff-added">.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (</span><span class="diff-added"><span class="diff-refine-added">is</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">on_idle</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">workers_set</span></span><span class="diff-added">) {
</span><span class="diff-context">     if (CanCleanupLockRequired(worker)) {
       CleanupLockRequired(executor, worker);
     }
     return false;
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // If too many workers are </span><span class="diff-removed"><span class="diff-refine-removed">currently awake (contrasted with ThreadGroupImpl
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // where this decision is made by the number of workers which were signaled)</span></span><span class="diff-removed">,
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  //</span></span><span class="diff-removed"> this worker should not get work, until tasks are no longer in excess
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  //</span></span><span class="diff-removed"> (i.e. max tasks increases).
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (</span><span class="diff-removed"><span class="diff-refine-removed">static_cast&lt;size_t&gt;(</span></span><span class="diff-removed">outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">num_active_signals_</span></span><span class="diff-removed">) &gt; outer()-&gt;max_tasks_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // If too many workers are </span><span class="diff-added"><span class="diff-refine-added">running</span></span><span class="diff-added">, this worker should not get work, until
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  //</span></span><span class="diff-added"> tasks are no longer in excess (i.e. max tasks increases). </span><span class="diff-added"><span class="diff-refine-added">This ensures that
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // if this worker is in excess, it gets a chance to being cleaned up.</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">GetNumAwakeWorkersLockRequired(</span></span><span class="diff-added">) &gt; outer()-&gt;max_tasks_) {
</span><span class="diff-context">     OnWorkerBecomesIdleLockRequired(executor, worker);
     return false;
   }
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context">   return true;
 }
 
 RegisteredTaskSource
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::GetWorkLockRequired(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor* executor,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">* worker) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  DCHECK</span><span class="diff-removed"><span class="diff-refine-removed">_CALLED_ON_VALID_THREAD</span></span><span class="diff-removed">(worker</span><span class="diff-removed"><span class="diff-refine-removed">_thread_checker_</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::GetWorkLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">    ScopedCommandsExecutor* executor,
</span><span class="diff-indicator-added">+</span><span class="diff-added">    WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">* worker) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(</span><span class="diff-added"><span class="diff-refine-added">ContainsWorker(outer()-&gt;workers_,</span></span><span class="diff-added"> worker</span><span class="diff-added"><span class="diff-refine-added">)</span></span><span class="diff-added">);
</span><span class="diff-context"> 
   if (!outer()-&gt;after_start().ensure_enough_workers_at_end_of_get_work) {
     // Use this opportunity, before assigning work to this worker, to
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // create/</span><span class="diff-removed"><span class="diff-refine-removed">signal</span></span><span class="diff-removed"> additional workers if needed (doing this here allows us to
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // create/</span><span class="diff-added"><span class="diff-refine-added">wake</span></span><span class="diff-added"> additional workers if needed (doing this here allows us to
</span><span class="diff-context">     // reduce potentially expensive create/wake directly on PostTask()).
     //
     // Note: FlushWorkerCreation() below releases |outer()-&gt;lock_|. It is thus
</span><span class="diff-hunk-header">@@ -405,6 +385,7 @@</span>
<span class="diff-context"> 
   // Running task bookkeeping.
   outer()-&gt;IncrementTasksRunningLockRequired(priority);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(!outer()-&gt;idle_workers_set_.Contains(worker));
</span><span class="diff-context"> 
   AnnotateAcquiredLockAlias annotate(outer()-&gt;lock_, lock());
   write_worker().current_task_priority = priority;
</span><span class="diff-hunk-header">@@ -432,22 +413,22 @@</span>
<span class="diff-context">   return task_source;
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">RegisteredTaskSource ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::GetWork(
</span><span class="diff-indicator-added">+</span><span class="diff-added">RegisteredTaskSource ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::GetWork(
</span><span class="diff-context">     WorkerThread* worker_base) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
   DCHECK(!read_worker().current_task_priority);
   DCHECK(!read_worker().current_shutdown_behavior);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor executor(outer());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor executor(outer());
</span><span class="diff-context">   CheckedAutoLock auto_lock(outer()-&gt;lock_);
 
   return GetWorkLockRequired(&amp;executor, worker);
 }
 
 RegisteredTaskSource
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::SwapProcessedTask(
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::SwapProcessedTask(
</span><span class="diff-context">     RegisteredTaskSource task_source,
     WorkerThread* worker) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-hunk-header">@@ -465,7 +446,14 @@</span>
<span class="diff-context">             std::move(task_source)));
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor workers_executor(outer());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">// Calling WakeUp() guarantees that this WorkerThread will run Tasks from
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // TaskSources returned by the GetWork() method of |delegate_| until it
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // returns nullptr. Resetting |wake_up_event_| here doesn't break this
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // invariant and avoids a useless loop iteration before going to sleep if
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // WakeUp() is called while this WorkerThread is awake.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  wake_up_event_.Reset();
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  ScopedCommandsExecutor workers_executor(outer());
</span><span class="diff-context">   ScopedReenqueueExecutor reenqueue_executor;
   CheckedAutoLock auto_lock(outer()-&gt;lock_);
   AnnotateAcquiredLockAlias annotate(outer()-&gt;lock_, lock());
</span><span class="diff-hunk-header">@@ -494,99 +482,81 @@</span>
<span class="diff-context">   write_worker().current_task_priority = absl::nullopt;
 
   if (transaction_with_task_source) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // If there is a task to enqueue, we can swap it for another task without
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // changing DesiredNumAwakeWorkers(), and thus without worrying about
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // signaling/waiting.
</span><span class="diff-context">     outer()-&gt;ReEnqueueTaskSourceLockRequired(
         &amp;workers_executor, &amp;reenqueue_executor,
         std::move(transaction_with_task_source.value()));
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">return GetWorkLockRequired(&amp;workers_executor,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                               static_cast&lt;WorkerThreadSemaphore*&gt;(worker));
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  } else if (outer()-&gt;GetDesiredNumAwakeWorkersLockRequired() &gt;=
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">             static_cast&lt;size_t&gt;(outer()-&gt;num_active_signals_)) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    // When the thread pool wants more work to be run but hasn't signaled
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    // workers for it yet we can take advantage and grab more work without
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    // signal/wait contention.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">    return GetWorkLockRequired(&amp;workers_executor,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                               static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">*&gt;(worker))</span><span class="diff-removed"><span class="diff-refine-removed">;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  }
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // In the case where the worker does not have a task source to exchange and
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // the thread group doesn't want more work than the number of workers awake,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // it must WaitForWork(), to keep |num_active_signals| synchronized with the
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // number of desired awake workers.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  OnWorkerBecomesIdleLockRequired(&amp;workers_executor, worker);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  return nullptr</span></span><span class="diff-removed">;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return GetWorkLockRequired(&amp;workers_executor,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                             static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">*&gt;(worker));
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">TimeDelta</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::</span><span class="diff-removed"><span class="diff-refine-removed">GetSleepTimeout</span></span><span class="diff-removed">() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return </span><span class="diff-removed"><span class="diff-refine-removed">ThreadPoolSleepTimeout()</span></span><span class="diff-removed">;
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">bool</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::</span><span class="diff-added"><span class="diff-refine-added">IsExcess</span></span><span class="diff-added">() </span><span class="diff-added"><span class="diff-refine-added">const</span></span><span class="diff-added"> {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return </span><span class="diff-added"><span class="diff-refine-added">is_excess_</span></span><span class="diff-added">;
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore::SemaphoreWorkerDelegate::IsExcess() const {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // Contrasted to ThreadGroup</span></span><span class="diff-removed">Impl</span><span class="diff-removed"><span class="diff-refine-removed">, where its workers residing somewhere in the
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // stack is either excess or not - all workers in this group can be in
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // excess. What is important is whether there are currently more workers than
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // this group's initial max tasks.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  return !outer()-&gt;after_start().no_worker_reclaim ||
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">         outer()-&gt;workers_in_excess_.load(std</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">memory_order_acquire);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">bool ThreadGroupSemaphore::Semaphore</span></span><span class="diff-removed">WorkerDelegate::CanCleanupLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">bool ThreadGroupImpl::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::CanCleanupLockRequired(
</span><span class="diff-context">     const WorkerThread* worker) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> IsExcess() &amp;&amp; LIKELY(!outer()-&gt;worker_cleanup_disallowed_for_testing_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">if</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">(!</span></span><span class="diff-added">IsExcess()</span><span class="diff-added"><span class="diff-refine-added">) {
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    return false;
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  }
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  const TimeTicks last_used_time = worker-&gt;GetLastUsedTime();
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  return !last_used_time.is_null() &amp;&amp;
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">         subtle::TimeTicksNowIgnoringOverride() - last_used_time &gt;=
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">             outer()-&gt;after_start().suggested_reclaim_time</span></span><span class="diff-added"> &amp;&amp;
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">         LIKELY(!outer()-&gt;worker_cleanup_disallowed_for_testing_);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::CleanupLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::CleanupLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* executor,
     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context">   DCHECK(!outer()-&gt;join_for_testing_started_);
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
 
   worker-&gt;Cleanup();
 
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (outer()-&gt;IsOnIdleSetLockRequired(worker)) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    outer()-&gt;idle_workers_set_.Remove(worker);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context">   // Remove the worker from |workers_|.
   auto worker_iter = ranges::find(outer()-&gt;workers_, worker);
   DCHECK(worker_iter != outer()-&gt;workers_.end());
   outer()-&gt;workers_.erase(worker_iter);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (outer()-&gt;after_start().no_worker_reclaim &amp;&amp;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      outer()-&gt;workers_.size() &lt;= outer()-&gt;after_start().initial_max_tasks) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    outer()-&gt;workers_in_excess_.store(false, std::memory_order_release);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate::
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate::
</span><span class="diff-context">     OnWorkerBecomesIdleLockRequired(BaseScopedCommandsExecutor* executor,
                                     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK_CALLED_ON_VALID_THREAD(</span></span><span class="diff-removed">worker</span><span class="diff-removed"><span class="diff-refine-removed">_thread_checker_);</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">--outer()-&gt;num_active_signals_;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">outer()-</span></span><span class="diff-removed">&gt;worker_</span><span class="diff-removed"><span class="diff-refine-removed">idle_cv_for_testing_-&gt;Signal();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  CHECK_GE(outer()-&gt;num_active_signals_, 0</span></span><span class="diff-removed">);
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}</span></span><span class="diff-removed">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">WorkerThreadWaitableEvent*</span></span><span class="diff-added"> worker </span><span class="diff-added"><span class="diff-refine-added">=</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">static_cast&lt;WorkerThreadWaitableEvent*</span></span><span class="diff-added">&gt;</span><span class="diff-added"><span class="diff-refine-added">(</span></span><span class="diff-added">worker_</span><span class="diff-added"><span class="diff-refine-added">base</span></span><span class="diff-added">);
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroupSemaphore::SemaphoreWorkerDelegate::RecordUnnecessaryWakeup() {
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(!outer()-&gt;idle_workers_set_.Contains(worker));
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // Add the worker to the idle set.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  outer()-&gt;idle_workers_set_.Insert(worker);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK_LE(outer()-&gt;idle_workers_set_.Size(), outer()-&gt;workers_.size());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  outer()-&gt;idle_workers_set_cv_for_testing_-&gt;Broadcast();
</span><span class="diff-indicator-added">+</span><span class="diff-added">}
</span><span class="diff-context"> 
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroupImpl::WaitableEventWorkerDelegate::RecordUnnecessaryWakeup() {
</span><span class="diff-context">   base::BooleanHistogram::FactoryGet(
       std::string("ThreadPool.UnnecessaryWakeup.") + outer()-&gt;histogram_label_,
       base::Histogram::kUmaTargetedHistogramFlag)
       -&gt;Add(true);
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  TRACE_EVENT_INSTANT("wakeup.flow", "ThreadPool.UnnecessaryWakeup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">");
</span><span class="diff-indicator-added">+</span><span class="diff-added">  TRACE_EVENT_INSTANT("wakeup.flow", "ThreadPool.UnnecessaryWakeup");
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::JoinForTesting() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::JoinForTesting() {
</span><span class="diff-context">   decltype(workers_) workers_copy;
   {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    SemaphoreScopedCommandsExecutor executor(this);
</span><span class="diff-context">     CheckedAutoLock auto_lock(lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    AnnotateAcquiredLockAlias alias(lock_, executor.outer()-&gt;lock_);
</span><span class="diff-context">     priority_queue_.EnableFlushTaskSourcesOnDestroyForTesting();
 
     DCHECK_GT(workers_.size(), size_t(0))
</span><span class="diff-hunk-header">@@ -602,11 +572,6 @@</span>
<span class="diff-context">     // WorkerThread::JoinForTesting() without holding |lock_| since
     // WorkerThreads may need to access |workers_|.
     workers_copy = workers_;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // The semaphore is signaled in JoinForTesting.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    num_active_signals_ += workers_copy.size();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    executor.ScheduleSignal();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    join_called_for_testing_.Set();
</span><span class="diff-context">   }
   for (const auto&amp; worker : workers_copy) {
     worker-&gt;JoinForTesting();
</span><span class="diff-hunk-header">@@ -618,44 +583,80 @@</span>
<span class="diff-context">   workers_.clear();
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">CreateAndRegister</span></span><span class="diff-removed">WorkerLockRequired(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor* executor) {
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">size_t ThreadGroupImpl::NumberOfWorkersForTesting() const {
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  CheckedAutoLock auto_lock(lock_);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  return workers_.size();
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">}
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">size_t ThreadGroupImpl::NumberOfIdleWorkersForTesting() const {
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  CheckedAutoLock auto_lock(lock_);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  return idle_workers_set_.Size();
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">}
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">MaintainAtLeastOneIdle</span></span><span class="diff-added">WorkerLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">    ScopedCommandsExecutor* executor) {
</span><span class="diff-context">   if (workers_.size() == kMaxNumberOfWorkers) {
     return;
   }
   DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (!idle_workers_set_.IsEmpty()) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context">   if (workers_.size() &gt;= max_tasks_) {
     return;
   }
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  scoped_refptr&lt;WorkerThreadWaitableEvent&gt; new_worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      CreateAndRegisterWorkerLockRequired(executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(new_worker);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  idle_workers_set_.Insert(new_worker.get());
</span><span class="diff-indicator-added">+</span><span class="diff-added">}
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">scoped_refptr&lt;WorkerThreadWaitableEvent&gt;
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroupImpl::CreateAndRegisterWorkerLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">    ScopedCommandsExecutor* executor) {
</span><span class="diff-context">   DCHECK(!join_for_testing_started_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK_LT(workers_.size(), max_tasks_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(idle_workers_set_.IsEmpty());
</span><span class="diff-context"> 
   // WorkerThread needs |lock_| as a predecessor for its thread lock because in
   // GetWork(), |lock_| is first acquired and then the thread lock is acquired
   // when GetLastUsedTime() is called on the worker by CanGetWorkLockRequired().
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  scoped_refptr&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">&gt; worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      MakeRefCounted&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">&gt;(
</span><span class="diff-indicator-added">+</span><span class="diff-added">  scoped_refptr&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">&gt; worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      MakeRefCounted&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">&gt;(
</span><span class="diff-context">           thread_type_hint_,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">          std::make_unique&lt;</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">              tracked_ref_factory_.GetTrackedRef(), </span><span class="diff-removed"><span class="diff-refine-removed">&amp;join</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">called</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">for</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">testing</span></span><span class="diff-removed">_),
</span><span class="diff-indicator-added">+</span><span class="diff-added">          std::make_unique&lt;</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate&gt;(
</span><span class="diff-indicator-added">+</span><span class="diff-added">              tracked_ref_factory_.GetTrackedRef(),
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">              /* is</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">excess=*/after</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">start().no</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">worker_reclaim
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">                  ? workers</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">.size() &gt;= after_start().initial_max_tasks
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">                  : true</span></span><span class="diff-added">),
</span><span class="diff-context">           task_tracker_, worker_sequence_num_++, &amp;lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK(worker);</span></span><span class="diff-removed">
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context">   workers_.push_back(worker);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  DCHECK_LE(workers_.size(), max_tasks_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (after_start().no_worker_reclaim &amp;&amp;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      workers_.size() &gt; after_start().initial_max_tasks) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    workers_in_excess_.store(true, std::memory_order_release);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-context">   executor-&gt;ScheduleStart(worker);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK_LE(workers_.size(), max_tasks_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return worker;
</span><span class="diff-indicator-added">+</span><span class="diff-added">}
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">size_t ThreadGroupImpl::GetNumAwakeWorkersLockRequired() const {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK_GE(workers_.size(), idle_workers_set_.Size());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  size_t num_awake_workers = workers_.size() - idle_workers_set_.Size();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK_GE(num_awake_workers, num_running_tasks_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return num_awake_workers;
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::DidUpdateCanRunPolicy() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::DidUpdateCanRunPolicy() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
   EnsureEnoughWorkersLockRequired(&amp;executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::OnShutdownStarted() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::OnShutdownStarted() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
 
   // Don't do anything if the thread group isn't started.
</span><span class="diff-hunk-header">@@ -664,11 +665,11 @@</span>
<span class="diff-context">   }
 
   // Start a MAY_BLOCK scope on each worker that is already running a task.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  for (scoped_refptr&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">&gt;&amp; worker : workers_) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // The delegates of workers inside a ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed"> should be
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">Worker</span><span class="diff-removed"><span class="diff-refine-removed">Delegates</span></span><span class="diff-removed">.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate* delegate =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">        static_cast&lt;</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate*&gt;(worker-&gt;delegate());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  for (scoped_refptr&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">&gt;&amp; worker : workers_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // The delegates of workers inside a ThreadGroup should be
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // Worker</span><span class="diff-added"><span class="diff-refine-added">ThreadDelegateImpls</span></span><span class="diff-added">.
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate* delegate =
</span><span class="diff-indicator-added">+</span><span class="diff-added">        static_cast&lt;</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate*&gt;(worker-&gt;delegate());
</span><span class="diff-context">     AnnotateAcquiredLockAlias annotate(lock_, delegate-&gt;lock());
     delegate-&gt;OnShutdownStartedLockRequired(&amp;executor);
   }
</span><span class="diff-hunk-header">@@ -677,30 +678,38 @@</span>
<span class="diff-context">   shutdown_started_ = true;
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::EnsureEnoughWorkersLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::EnsureEnoughWorkersLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* base_executor) {
   // Don't do anything if the thread group isn't started.
   if (max_tasks_ == 0 || UNLIKELY(join_for_testing_started_)) {
     return;
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor* executor =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor*&gt;(base_executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor* executor =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;ScopedCommandsExecutor*&gt;(base_executor);
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const size_t desired_awake_workers = GetDesiredNumAwakeWorkersLockRequired();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const size_t </span><span class="diff-removed"><span class="diff-refine-removed">new</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">signals</span></span><span class="diff-removed"> =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      ClampSub(desired_awake_workers, num_</span><span class="diff-removed"><span class="diff-refine-removed">active_signals</span></span><span class="diff-removed">_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">const size_t</span></span><span class="diff-removed"> num_workers_to_</span><span class="diff-removed"><span class="diff-refine-removed">create</span></span><span class="diff-removed"> =
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">      std::min(</span><span class="diff-removed"><span class="diff-refine-removed">{static</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">cast&lt;</span></span><span class="diff-removed">size_t</span><span class="diff-removed"><span class="diff-refine-removed">&gt;</span></span><span class="diff-removed">(2)</span><span class="diff-removed"><span class="diff-refine-removed">,</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                </span><span class="diff-removed"><span class="diff-refine-removed">static_cast&lt;</span></span><span class="diff-removed">size_t</span><span class="diff-removed"><span class="diff-refine-removed">&gt;(
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">                    </span><span class="diff-removed"><span class="diff-refine-removed">ClampSub(desired_awake</span></span><span class="diff-removed">_workers + </span><span class="diff-removed"><span class="diff-refine-removed">1, workers_.size()))}</span></span><span class="diff-removed">)</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">AnnotateAcquired</span></span><span class="diff-removed">Lock</span><span class="diff-removed"><span class="diff-refine-removed">Alias alias</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">lock_,</span></span><span class="diff-removed"> executor</span><span class="diff-removed"><span class="diff-refine-removed">-&gt;outer()-&gt;lock_</span></span><span class="diff-removed">);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">for</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">(size_t</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">i</span></span><span class="diff-removed"> = </span><span class="diff-removed"><span class="diff-refine-removed">0</span></span><span class="diff-removed">; </span><span class="diff-removed"><span class="diff-refine-removed">i</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&lt;</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">new_signals;</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">++i)</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">{</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    executor-&gt;Schedule</span><span class="diff-removed"><span class="diff-refine-removed">Signal</span></span><span class="diff-removed">();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">for</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">(size_</span></span><span class="diff-removed">t </span><span class="diff-removed"><span class="diff-refine-removed">i</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">=</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">0;</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">i</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&lt;</span></span><span class="diff-removed"> num_workers_</span><span class="diff-removed"><span class="diff-refine-removed">to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">create; ++i</span></span><span class="diff-removed">) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">CreateAndRegister</span></span><span class="diff-removed">WorkerLockRequired(executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  const size_t desired_</span><span class="diff-added"><span class="diff-refine-added">num_</span></span><span class="diff-added">awake_workers =
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">      GetDesiredNumAwakeWorkersLockRequired();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  const size_t </span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">awake_workers = GetNumAwakeWorkersLockRequired();
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  size_t num_workers_to_wake_up</span></span><span class="diff-added"> =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      ClampSub(desired_</span><span class="diff-added"><span class="diff-refine-added">num_</span></span><span class="diff-added">awake_workers, num_</span><span class="diff-added"><span class="diff-refine-added">awake</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">workers</span></span><span class="diff-added">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  num_workers_to_</span><span class="diff-added"><span class="diff-refine-added">wake_up</span></span><span class="diff-added"> = std::min(</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">workers_to_wake_up,</span></span><span class="diff-added"> size_t(2</span><span class="diff-added"><span class="diff-refine-added">U</span></span><span class="diff-added">)</span><span class="diff-added"><span class="diff-refine-added">);</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">Wake</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">up</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">the</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">appropriate</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">number</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">of</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">workers.</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">for</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">(</span></span><span class="diff-added">size_t </span><span class="diff-added"><span class="diff-refine-added">i</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">=</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">0;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">i</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">&lt;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_workers</span><span class="diff-added"><span class="diff-refine-added">_to_wake_up;</span></span><span class="diff-added"> +</span><span class="diff-added"><span class="diff-refine-added">+i</span></span><span class="diff-added">) </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">MaintainAtLeastOneIdleWorker</span></span><span class="diff-added">Lock</span><span class="diff-added"><span class="diff-refine-added">Required</span></span><span class="diff-added">(executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">WorkerThreadWaitableEvent* worker_to_wakeup</span></span><span class="diff-added"> = </span><span class="diff-added"><span class="diff-refine-added">idle_workers_set_.Take()</span></span><span class="diff-added">;
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">DCHECK(worker_to_wakeup);</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    executor-&gt;Schedule</span><span class="diff-added"><span class="diff-refine-added">WakeUp</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">worker_to_wakeup</span></span><span class="diff-added">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">// In the case where the loop above didn'</span></span><span class="diff-added">t </span><span class="diff-added"><span class="diff-refine-added">wake</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">up</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">any</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">worker</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">and we don't
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // have excess workers, the idle worker should be maintained. This happens
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // when called from the last worker awake, or a recent increase in |max_tasks|
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // now makes it possible to keep an idle worker.</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  if (desired_</span></span><span class="diff-added">num_</span><span class="diff-added"><span class="diff-refine-added">awake_</span></span><span class="diff-added">workers </span><span class="diff-added"><span class="diff-refine-added">== num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">awake</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">workers</span></span><span class="diff-added">) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">MaintainAtLeastOneIdle</span></span><span class="diff-added">WorkerLockRequired(executor);
</span><span class="diff-context">   }
 
   // This function is called every time a task source is (re-)enqueued,
</span><span class="diff-hunk-header">@@ -711,22 +720,22 @@</span>
<span class="diff-context">   MaybeScheduleAdjustMaxTasksLockRequired(executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">::AdjustMaxTasks() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Impl</span></span><span class="diff-added">::AdjustMaxTasks() {
</span><span class="diff-context">   DCHECK(
       after_start().service_thread_task_runner-&gt;RunsTasksInCurrentSequence());
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
   DCHECK(adjust_max_tasks_posted_);
   adjust_max_tasks_posted_ = false;
 
   // Increment max tasks for each worker that has been within a MAY_BLOCK
   // ScopedBlockingCall for more than may_block_threshold.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  for (scoped_refptr&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">&gt; worker : workers_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  for (scoped_refptr&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">&gt; worker : workers_) {
</span><span class="diff-context">     // The delegates of workers inside a ThreadGroup should be
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegates.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate* delegate =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">        static_cast&lt;</span><span class="diff-removed"><span class="diff-refine-removed">Semaphore</span></span><span class="diff-removed">WorkerDelegate*&gt;(worker-&gt;delegate());
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // </span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegates.
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate* delegate =
</span><span class="diff-indicator-added">+</span><span class="diff-added">        static_cast&lt;</span><span class="diff-added"><span class="diff-refine-added">WaitableEvent</span></span><span class="diff-added">WorkerDelegate*&gt;(worker-&gt;delegate());
</span><span class="diff-context">     AnnotateAcquiredLockAlias annotate(lock_, delegate-&gt;lock());
     delegate-&gt;MaybeIncrementMaxTasksLockRequired();
   }
</span><span class="diff-hunk-header">@@ -736,5 +745,14 @@</span>
<span class="diff-context">   EnsureEnoughWorkersLockRequired(&amp;executor);
 }
 
</span><span class="diff-indicator-added">+</span><span class="diff-added">bool ThreadGroupImpl::IsOnIdleSetLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">    WorkerThreadWaitableEvent* worker) const {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // To avoid searching through the idle set : use GetLastUsedTime() not being
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // null (or being directly on top of the idle set) as a proxy for being on
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // the idle set.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return idle_workers_set_.Peek() == worker ||
</span><span class="diff-indicator-added">+</span><span class="diff-added">         !worker-&gt;GetLastUsedTime().is_null();
</span><span class="diff-indicator-added">+</span><span class="diff-added">}
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-context"> }  // namespace internal
 }  // namespace base

Diff finished.  Fri Jan 12 14:36:32 2024
</span></pre>
  </body>
</html>
