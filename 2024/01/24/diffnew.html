<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.57 in css mode. -->
<html>
  <head>
    <title>*Diff*</title>
    <style type="text/css">
    <!--
      body {
        color: #c7c9cb;
        background-color: #232530;
      }
      .diff-added {
        /* diff-added */
        color: #09f7a0;
        background-color: #1c1e26;
      }
      .diff-context {
        /* diff-context */
        color: #afb0b2;
      }
      .diff-file-header {
        /* diff-file-header */
        color: #21bfc2;
      }
      .diff-header {
        /* diff-header */
        color: #59e3e3;
      }
      .diff-hunk-header {
        /* diff-hunk-header */
        color: #b877db;
      }
      .diff-indicator-added {
        /* diff-indicator-added */
        color: #22aa22;
        background-color: #1c1e26;
      }
      .diff-indicator-removed {
        /* diff-indicator-removed */
        color: #aa2222;
        background-color: #232530;
      }
      .diff-refine-added {
        /* diff-refine-added */
        color: #09f7a0;
        background-color: #1c1e26;
      }
      .diff-refine-removed {
        /* diff-refine-removed */
        color: #e95678;
        background-color: #232530;
      }
      .diff-removed {
        /* diff-removed */
        color: #e95678;
        background-color: #232530;
      }
      .hl-line {
        /* hl-line */
        background-color: #1c1e26;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="diff-header">diff -u --label \#\&lt;buffer\ thread_group_impl.cc\&gt; --label \#\&lt;buffer\ thread_group_semaphore.cc\&gt; /tmp/buffer-content-uVFM5Z /tmp/buffer-content-9isHuW
</span><span class="diff-header"><span class="hl-line">--- </span></span><span class="diff-header"><span class="diff-file-header"><span class="hl-line">#&lt;buffer thread_group_impl.cc&gt;</span></span></span><span class="diff-header"><span class="hl-line">
</span></span><span class="diff-header">+++ </span><span class="diff-header"><span class="diff-file-header">#&lt;buffer thread_group_semaphore.cc&gt;</span></span><span class="diff-header">
</span><span class="diff-hunk-header">@@ -1,94 +1,97 @@</span>
<span class="diff-indicator-removed">-</span><span class="diff-removed">// Copyright 2016 The Chromium Authors
</span><span class="diff-indicator-added">+</span><span class="diff-added">// Copyright 2024 The Chromium Authors
</span><span class="diff-context"> // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/thread_group_impl.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/thread_group_semaphore.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include &lt;algorithm&gt;
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/auto_reset.h"
</span><span class="diff-context"> #include "base/metrics/histogram_macros.h"
 #include "base/sequence_token.h"
 #include "base/strings/string_piece.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/strings/stringprintf.h"
</span><span class="diff-context"> #include "base/task/common/checked_lock.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/thread_group_worker_delegate.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "base/task/thread_pool/worker_thread_waitable_event.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/thread_group.h"
</span><span class="diff-indicator-added">+</span><span class="diff-added">#include "base/task/thread_pool/worker_thread_semaphore.h"
</span><span class="diff-context"> #include "base/threading/scoped_blocking_call.h"
 #include "base/threading/scoped_blocking_call_internal.h"
 #include "base/threading/thread_checker.h"
 #include "base/time/time_override.h"
 #include "base/trace_event/base_tracing.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "third_party/abseil-cpp/absl/container/inlined_vector.h"
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">#include "third_party/abseil-cpp/absl/types/optional.h"
</span><span class="diff-context"> 
 namespace base {
 namespace internal {
 
 namespace {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context"> constexpr size_t kMaxNumberOfWorkers = 256;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context"> }  // namespace
 
 // Upon destruction, executes actions that control the number of active workers.
 // Useful to satisfy locking requirements of these actions.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">class ThreadGroupImpl::ScopedCommandsExecutor
</span><span class="diff-indicator-added">+</span><span class="diff-added">class ThreadGroupSemaphore::SemaphoreScopedCommandsExecutor
</span><span class="diff-context">     : public ThreadGroup::BaseScopedCommandsExecutor {
  public:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  explicit ScopedCommandsExecutor(ThreadGroupImpl* outer)
</span><span class="diff-indicator-added">+</span><span class="diff-added">  explicit SemaphoreScopedCommandsExecutor(ThreadGroupSemaphore* outer)
</span><span class="diff-context">       : BaseScopedCommandsExecutor(outer) {}
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor(const ScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor&amp; operator=(const ScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ~ScopedCommandsExecutor() override {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreScopedCommandsExecutor(const SemaphoreScopedCommandsExecutor&amp;) =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreScopedCommandsExecutor&amp; operator=(
</span><span class="diff-indicator-added">+</span><span class="diff-added">      const SemaphoreScopedCommandsExecutor&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ~SemaphoreScopedCommandsExecutor() override {
</span><span class="diff-context">     CheckedLock::AssertNoLockHeldOnCurrentThread();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // Wake up workers.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    for (auto worker : workers_to_wake_up_) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      worker-&gt;WakeUp();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    for (int i = 0; i &lt; semaphore_signal_count_; ++i) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      outer()-&gt;semaphore_.Signal();
</span><span class="diff-context">     }
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  void ScheduleWakeUp(scoped_refptr&lt;WorkerThreadWaitableEvent&gt; worker) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    workers_to_wake_up_.emplace_back(std::move(worker));
</span><span class="diff-indicator-added">+</span><span class="diff-added">  void ScheduleSignal() EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    ++semaphore_signal_count_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">    ++outer()-&gt;num_active_signals_;
</span><span class="diff-context">   }
 
  private:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  absl::InlinedVector&lt;scoped_refptr&lt;WorkerThreadWaitableEvent&gt;, 2&gt;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      workers_to_wake_up_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  friend class ThreadGroupSemaphore;
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ThreadGroupSemaphore* outer() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  int semaphore_signal_count_ = 0;
</span><span class="diff-context"> };
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">class ThreadGroupImpl::WaitableEventWorkerDelegate
</span><span class="diff-indicator-added">+</span><span class="diff-added">class ThreadGroupSemaphore::SemaphoreWorkerDelegate
</span><span class="diff-context">     : public ThreadGroup::ThreadGroupWorkerDelegate,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      public WorkerThreadWaitableEvent::Delegate {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      public WorkerThreadSemaphore::Delegate {
</span><span class="diff-context">  public:
   // |outer| owns the worker for which this delegate is constructed. If
   // |is_excess| is true, this worker will be eligible for reclaim.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  explicit WaitableEventWorkerDelegate(TrackedRef&lt;ThreadGroup&gt; outer,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                       bool is_excess);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WaitableEventWorkerDelegate(const WaitableEventWorkerDelegate&amp;) = delete;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WaitableEventWorkerDelegate&amp; operator=(const WaitableEventWorkerDelegate&amp;) =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  explicit SemaphoreWorkerDelegate(TrackedRef&lt;ThreadGroup&gt; outer,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                   AtomicFlag* join_called_for_testing);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreWorkerDelegate(const SemaphoreWorkerDelegate&amp;) = delete;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  SemaphoreWorkerDelegate&amp; operator=(const SemaphoreWorkerDelegate&amp;) = delete;
</span><span class="diff-context"> 
   // OnMainExit() handles the thread-affine cleanup;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // WaitableEventWorkerDelegate can thereafter safely be deleted from any
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // thread.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ~WaitableEventWorkerDelegate() override = default;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // SemaphoreWorkerDelegate can thereafter safely be deleted from any thread.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ~SemaphoreWorkerDelegate() override = default;
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // ThreadGroup::Delegate:
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // WorkerThread::Delegate:
</span><span class="diff-context">   void OnMainEntry(WorkerThread* worker) override;
   void OnMainExit(WorkerThread* worker) override;
   RegisteredTaskSource GetWork(WorkerThread* worker) override;
   RegisteredTaskSource SwapProcessedTask(RegisteredTaskSource task_source,
                                          WorkerThread* worker) override;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // WorkerThreadWaitableEvent::Delegate:
</span><span class="diff-context">   void RecordUnnecessaryWakeup() override;
   // True if the calling worker is be eligible for reclaim.
   bool IsExcess() const override;
   TimeDelta GetSleepTimeout() override;
 
  private:
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ThreadGroupImpl* outer() const {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return static_cast&lt;ThreadGroupImpl*&gt;(outer_.get());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  const ThreadGroupSemaphore* outer() const {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_.get());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  }
</span><span class="diff-indicator-added">+</span><span class="diff-added">  ThreadGroupSemaphore* outer() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return static_cast&lt;ThreadGroupSemaphore*&gt;(outer_.get());
</span><span class="diff-context">   }
 
   // ThreadGroup::ThreadGroupWorkerDelegate:
</span><span class="diff-hunk-header">@@ -106,21 +109,19 @@</span>
<span class="diff-context">   // thread group. Called from GetWork() when no work is available.
   bool CanCleanupLockRequired(const WorkerThread* worker)
       EXCLUSIVE_LOCKS_REQUIRED(outer()-&gt;lock_) override;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const bool is_excess_;
</span><span class="diff-context"> };
 
 std::unique_ptr&lt;ThreadGroup::BaseScopedCommandsExecutor&gt;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::GetExecutor() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::GetExecutor() {
</span><span class="diff-context">   return static_cast&lt;std::unique_ptr&lt;BaseScopedCommandsExecutor&gt;&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      std::make_unique&lt;ScopedCommandsExecutor&gt;(this));
</span><span class="diff-indicator-added">+</span><span class="diff-added">      std::make_unique&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor&gt;(this));
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">(StringPiece histogram_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 StringPiece thread_group_label,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 ThreadType thread_type_hint,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 TrackedRef&lt;TaskTracker&gt; task_tracker,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                                 TrackedRef&lt;Delegate&gt; delegate)
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">(StringPiece histogram_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           StringPiece thread_group_label,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           ThreadType thread_type_hint,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           TrackedRef&lt;TaskTracker&gt; task_tracker,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                           TrackedRef&lt;Delegate&gt; delegate)
</span><span class="diff-context">     : ThreadGroup(histogram_label,
                   thread_group_label,
                   thread_type_hint,
</span><span class="diff-hunk-header">@@ -130,7 +131,7 @@</span>
<span class="diff-context">   DCHECK(!thread_group_label_.empty());
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::Start(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::Start(
</span><span class="diff-context">     size_t max_tasks,
     size_t max_best_effort_tasks,
     TimeDelta suggested_reclaim_time,
</span><span class="diff-hunk-header">@@ -144,13 +145,13 @@</span>
<span class="diff-context">       service_thread_task_runner, worker_thread_observer, worker_environment,
       synchronous_thread_start_for_testing, may_block_threshold);
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
   DCHECK(workers_.empty());
   EnsureEnoughWorkersLockRequired(&amp;executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::~ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::~ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">() {
</span><span class="diff-context">   // ThreadGroup should only ever be deleted:
   //  1) In tests, after JoinForTesting().
   //  2) In production, iff initialization failed.
</span><span class="diff-hunk-header">@@ -158,52 +159,53 @@</span>
<span class="diff-context">   DCHECK(workers_.empty());
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::UpdateSortKey(TaskSource::Transaction transaction) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::UpdateSortKey(TaskSource::Transaction transaction) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   UpdateSortKeyImpl(&amp;executor, std::move(transaction));
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::PushTaskSourceAndWakeUpWorkers(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::PushTaskSourceAndWakeUpWorkers(
</span><span class="diff-context">     RegisteredTaskSourceAndTransaction transaction_with_task_source) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   PushTaskSourceAndWakeUpWorkersImpl(&amp;executor,
                                      std::move(transaction_with_task_source));
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl::WaitableEventWorkerDelegate</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEventWorkerDelegate</span></span><span class="diff-removed">(
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">TrackedRef&lt;ThreadGroup&gt;</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">outer,</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">bool</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">is</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">excess</span></span><span class="diff-removed">)
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">:</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">ThreadGroupWorkerDelegate</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">std::move</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">outer)), is</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">excess</span></span><span class="diff-removed">_(</span><span class="diff-removed"><span class="diff-refine-removed">is</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">excess</span></span><span class="diff-removed">) </span><span class="diff-removed"><span class="diff-refine-removed">{</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">//</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">Bound</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">in</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">OnMainEntry().</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DETACH</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">FROM</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">THREAD</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">thread</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">checker</span></span><span class="diff-removed">_);
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">size_t</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">NumberOfIdleWorkersLockRequiredForTesting</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">)</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">const</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">return</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">std::max(</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t(ClampSub(workers_.size(</span></span><span class="diff-added">)</span><span class="diff-added"><span class="diff-refine-added">, max_tasks_)),</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">static_cast&lt;size_t&gt;</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">ClampSub</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">static</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">cast&lt;int64</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t&gt;</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">workers</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">.size(</span></span><span class="diff-added">)</span><span class="diff-added"><span class="diff-refine-added">),</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">                                   </span><span class="diff-added"><span class="diff-refine-added">static</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">cast&lt;int64</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t&gt;</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">active</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">)))</span></span><span class="diff-added">);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">TimeDelta</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::</span><span class="diff-removed"><span class="diff-refine-removed">GetSleepTimeout</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">{</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> Thread</span><span class="diff-removed"><span class="diff-refine-removed">PoolSleepTimeout</span></span><span class="diff-removed">()</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">}
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::</span><span class="diff-added"><span class="diff-refine-added">SemaphoreWorkerDelegate</span></span><span class="diff-added">(
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    TrackedRef&lt;ThreadGroup&gt; outer,
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    AtomicFlag* join_called_for_testing</span></span><span class="diff-added">)
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    : ThreadGroupWorkerDelegate(std::move(outer)),</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">Delegate(&amp;static_cast&lt;</span></span><span class="diff-added">Thread</span><span class="diff-added"><span class="diff-refine-added">GroupSemaphore*&gt;(outer.get</span></span><span class="diff-added">()</span><span class="diff-added"><span class="diff-refine-added">)-&gt;semaphore_,</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">               </span><span class="diff-added"><span class="diff-refine-added">join_called_for_testing) {</span></span><span class="diff-added">}
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::OnMainEntry(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::OnMainEntry(
</span><span class="diff-context">     WorkerThread* worker) {
   OnMainEntryImpl(worker);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::OnMainExit(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::OnMainExit(
</span><span class="diff-context">     WorkerThread* worker_base) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
 
 #if DCHECK_IS_ON()
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context">   {
     bool shutdown_complete = outer()-&gt;task_tracker_-&gt;IsShutdownComplete();
     CheckedAutoLock auto_lock(outer()-&gt;lock_);
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    // |worker| should already have been removed from </span><span class="diff-removed"><span class="diff-refine-removed">the idle workers set and
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> |workers_| by the time the thread is about to exit. (except in the
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> cases where the thread group is no longer going to be used - in which
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    //</span></span><span class="diff-removed"> case, it's fine for there to be invalid workers in the thread group).
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    if (!shutdown_complete &amp;&amp; !outer()-&gt;join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      DCHECK(!outer()-&gt;idle_workers_set_</span></span><span class="diff-removed">.</span><span class="diff-removed"><span class="diff-refine-removed">Contains</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">))</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // |worker| should already have been removed from |workers_| by the time the
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> thread is about to exit. (except in the cases where the thread group is
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> no longer going to be used - in which case, it's fine for there to be
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    //</span></span><span class="diff-added"> invalid workers in the thread group).
</span><span class="diff-indicator-added">+</span><span class="diff-added">    if (!shutdown_complete &amp;&amp; !outer()-&gt;join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_.</span><span class="diff-added"><span class="diff-refine-added">IsSet</span></span><span class="diff-added">()) </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">
</span><span class="diff-context">       DCHECK(!ContainsWorker(outer()-&gt;workers_, worker));
     }
   }
</span><span class="diff-hunk-header">@@ -228,54 +230,49 @@</span>
<span class="diff-context">   }
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::CanGetWorkLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">bool ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::CanGetWorkLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* executor,
     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker_base</span><span class="diff-removed"><span class="diff-refine-removed">);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  const bool is_on_idle_workers_set = outer()-&gt;IsOnIdleSetLockRequired(worker);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_EQ(is_on_idle_workers_set,
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">            outer()-&gt;idle_workers_set_.Contains(worker)</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-context"> 
   AnnotateAcquiredLockAlias annotate(outer()-&gt;lock_, lock());
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // </span><span class="diff-removed"><span class="diff-refine-removed">This occurs</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">when</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">the</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">when</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">WorkerThread::Delegate::</span></span><span class="diff-removed">Wait</span><span class="diff-removed"><span class="diff-refine-removed">ForWork</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">times out
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // (i.e. when the worker's wakes up after GetSleepTimeout())</span></span><span class="diff-removed">.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (</span><span class="diff-removed"><span class="diff-refine-removed">is_on_idle</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // </span><span class="diff-added"><span class="diff-refine-added">|timed_out_|</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">is</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">set</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">by</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">Timed</span></span><span class="diff-added">Wait().
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (</span><span class="diff-added"><span class="diff-refine-added">timed</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">out</span></span><span class="diff-added">_) {
</span><span class="diff-context">     if (CanCleanupLockRequired(worker)) {
       CleanupLockRequired(executor, worker);
     }
     return false;
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // If too many workers are </span><span class="diff-removed"><span class="diff-refine-removed">running</span></span><span class="diff-removed">, this worker should not get work, until
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  //</span></span><span class="diff-removed"> tasks are no longer in excess (i.e. max tasks increases). </span><span class="diff-removed"><span class="diff-refine-removed">This ensures that
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // if this worker is in excess, it gets a chance to being cleaned up.</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">GetNumAwakeWorkersLockRequired(</span></span><span class="diff-removed">) &gt; outer()-&gt;max_tasks_) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  // If too many workers are </span><span class="diff-added"><span class="diff-refine-added">currently awake (contrasted with ThreadGroupImpl
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // where this decision is made by the number of workers which were signaled)</span></span><span class="diff-added">,
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  //</span></span><span class="diff-added"> this worker should not get work, until tasks are no longer in excess
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  //</span></span><span class="diff-added"> (i.e. max tasks increases).
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (</span><span class="diff-added"><span class="diff-refine-added">static_cast&lt;size_t&gt;(</span></span><span class="diff-added">outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num_active_signals_</span></span><span class="diff-added">) &gt; outer()-&gt;max_tasks_) {
</span><span class="diff-context">     OnWorkerBecomesIdleLockRequired(executor, worker);
     return false;
   }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context">   return true;
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">RegisteredTaskSource ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::GetWork(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    WorkerThread* worker</span><span class="diff-removed"><span class="diff-refine-removed">_base</span></span><span class="diff-removed">) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">RegisteredTaskSource ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::GetWork(
</span><span class="diff-indicator-added">+</span><span class="diff-added">    WorkerThread* worker) {
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
   DCHECK(!read_worker().current_task_priority);
   DCHECK(!read_worker().current_shutdown_behavior);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThreadWaitableEvent* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThreadWaitableEvent*&gt;(worker_base);
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(outer());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(outer());
</span><span class="diff-context">   CheckedAutoLock auto_lock(outer()-&gt;lock_);
   AnnotateAcquiredLockAlias alias(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      outer()-&gt;lock_, static_cast&lt;ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">*&gt;(outer_.get())-&gt;lock_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">      outer()-&gt;lock_, static_cast&lt;ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(outer_.get())-&gt;lock_);
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">
</span><span class="diff-context">   return GetWorkLockRequired(&amp;executor, worker);
 }
 
 RegisteredTaskSource
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::SwapProcessedTask(
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::SwapProcessedTask(
</span><span class="diff-context">     RegisteredTaskSource task_source,
     WorkerThread* worker) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-hunk-header">@@ -293,14 +290,7 @@</span>
<span class="diff-context">             std::move(task_source)));
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">// Calling WakeUp() guarantees that this WorkerThread will run Tasks from
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // TaskSources returned by the GetWork() method of |delegate_| until it
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // returns nullptr. Resetting |wake_up_event_| here doesn't break this
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // invariant and avoids a useless loop iteration before going to sleep if
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // WakeUp() is called while this WorkerThread is awake.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  wake_up_event_.Reset();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  ScopedCommandsExecutor workers_executor(outer());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor workers_executor(outer());
</span><span class="diff-context">   ScopedReenqueueExecutor reenqueue_executor;
   CheckedAutoLock auto_lock(outer()-&gt;lock_);
   AnnotateAcquiredLockAlias annotate(outer()-&gt;lock_, lock());
</span><span class="diff-hunk-header">@@ -329,82 +319,101 @@</span>
<span class="diff-context">   write_worker().current_task_priority = absl::nullopt;
 
   if (transaction_with_task_source) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // If there is a task to enqueue, we can swap it for another task without
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // changing DesiredNumAwakeWorkers(), and thus without worrying about
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // signaling/waiting.
</span><span class="diff-context">     outer()-&gt;ReEnqueueTaskSourceLockRequired(
         &amp;workers_executor, &amp;reenqueue_executor,
         std::move(transaction_with_task_source.value()));
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return GetWorkLockRequired(&amp;workers_executor,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">                             static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker));
</span><span class="diff-indicator-added">+</span><span class="diff-added">    return GetWorkLockRequired(&amp;workers_executor,
</span><span class="diff-indicator-added">+</span><span class="diff-added">                               static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore*&gt;(worker));
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  } else if (outer()-&gt;GetDesiredNumAwakeWorkersLockRequired() &gt;=
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">             static_cast&lt;size_t&gt;(outer()-&gt;num_active_signals_)) {
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    // When the thread pool wants more work to be run but hasn't signaled
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    // workers for it yet we can take advantage and grab more work without
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    // signal/wait contention.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    return GetWorkLockRequired(&amp;workers_executor,
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">                               static_cast&lt;WorkerThreadSemaphore</span></span><span class="diff-added">*&gt;(worker))</span><span class="diff-added"><span class="diff-refine-added">;
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  }
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // In the case where the worker does not have a task source to exchange and
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // the thread group doesn't want more work than the number of workers awake,
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // it must WaitForWork(), to keep |num_active_signals| synchronized with the
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // number of desired awake workers.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  OnWorkerBecomesIdleLockRequired(&amp;workers_executor, worker);
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  return nullptr</span></span><span class="diff-added">;
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">bool</span></span><span class="diff-removed"> ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::</span><span class="diff-removed"><span class="diff-refine-removed">IsExcess</span></span><span class="diff-removed">() </span><span class="diff-removed"><span class="diff-refine-removed">const</span></span><span class="diff-removed"> {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return </span><span class="diff-removed"><span class="diff-refine-removed">is_excess_</span></span><span class="diff-removed">;
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">TimeDelta</span></span><span class="diff-added"> ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::</span><span class="diff-added"><span class="diff-refine-added">GetSleepTimeout</span></span><span class="diff-added">() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  return </span><span class="diff-added"><span class="diff-refine-added">ThreadPoolSleepTimeout()</span></span><span class="diff-added">;
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::</span><span class="diff-removed"><span class="diff-refine-removed">CanCleanupLockRequired</span></span><span class="diff-removed">(
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">    const </span><span class="diff-removed"><span class="diff-refine-removed">WorkerThread* worker)</span></span><span class="diff-removed"> {
</span><span class="diff-indicator-added">+</span><span class="diff-added">bool ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::</span><span class="diff-added"><span class="diff-refine-added">IsExcess</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">)</span></span><span class="diff-added"> const {
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (!IsExcess()) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return false;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">const</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">TimeTicks</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">last_used_time</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">=</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">worker-&gt;GetLastUsedTime();</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">!last_used_time.</span></span><span class="diff-removed">is</span><span class="diff-removed"><span class="diff-refine-removed">_null()</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&amp;&amp;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">         </span><span class="diff-removed"><span class="diff-refine-removed">subtle::TimeTicksNowIgnoringOverride()</span></span><span class="diff-removed"> - </span><span class="diff-removed"><span class="diff-refine-removed">last_used_time</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&gt;=</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">             outer()-&gt;after_start().</span><span class="diff-removed"><span class="diff-refine-removed">suggested</span></span><span class="diff-removed">_reclaim_</span><span class="diff-removed"><span class="diff-refine-removed">time</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">&amp;&amp;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">         LIKELY(!outer()-&gt;worker_cleanup_disallowed_for_testing_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">Contrasted</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">to</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">ThreadGroupImpl,</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">where its workers residing somewhere in the</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">// stack</span></span><span class="diff-added"> is </span><span class="diff-added"><span class="diff-refine-added">either</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">excess</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">or</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">not</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">-</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">all</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">workers</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">in</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">this</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">group</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">can be in</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">excess. What is</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">important is</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">whether there</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">are</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">currently</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">more</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">workers</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">than</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">//</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">this</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">group's</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">initial max tasks.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  return !</span></span><span class="diff-added">outer()-&gt;after_start().</span><span class="diff-added"><span class="diff-refine-added">no_worker</span></span><span class="diff-added">_reclaim </span><span class="diff-added"><span class="diff-refine-added">||
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">         TS</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">UNCHECKED_READ(outer()-&gt;num_workers_in_excess_)</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">             .load(std::memory_order_relaxed);</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added"><span class="diff-refine-added">}</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">bool</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">ThreadGroupSemaphore::SemaphoreWorkerDelegate::CanCleanupLockRequired(
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">    const WorkerThread* worker) {
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">return</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">IsExcess()</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">&amp;&amp;</span></span><span class="diff-added"> LIKELY(!outer()-&gt;worker_cleanup_disallowed_for_testing_);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::CleanupLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::CleanupLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* executor,
     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker_base);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  DCHECK(!outer()-&gt;join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">* worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker_base);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(!outer()-&gt;join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_</span><span class="diff-added"><span class="diff-refine-added">.IsSet()</span></span><span class="diff-added">);
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
 
   worker-&gt;Cleanup();
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (outer()-&gt;IsOnIdleSetLockRequired(worker)) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    outer()-&gt;idle_workers_set_.Remove(worker);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context">   // Remove the worker from |workers_|.
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(outer()-&gt;after_start().no_worker_reclaim &amp;&amp;
</span><span class="diff-indicator-added">+</span><span class="diff-added">         outer()-&gt;workers_.size() &gt; outer()-&gt;after_start().initial_max_tasks);
</span><span class="diff-context">   auto worker_iter = ranges::find(outer()-&gt;workers_, worker);
   DCHECK(worker_iter != outer()-&gt;workers_.end());
   outer()-&gt;workers_.erase(worker_iter);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK_GT(
</span><span class="diff-indicator-added">+</span><span class="diff-added">      outer()-&gt;num_workers_in_excess_.fetch_sub(1, std::memory_order_relaxed),
</span><span class="diff-indicator-added">+</span><span class="diff-added">      0);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::
</span><span class="diff-context">     OnWorkerBecomesIdleLockRequired(BaseScopedCommandsExecutor* executor,
                                     WorkerThread* worker_base) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  WorkerThreadWaitableEvent* worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;WorkerThreadWaitableEvent*&gt;(worker_base);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context">   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK(!</span></span><span class="diff-removed">outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">idle</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Contains(worker))</span></span><span class="diff-removed">;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // Add the worker to the idle set.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  outer()-&gt;idle_workers_set_</span><span class="diff-removed"><span class="diff-refine-removed">.Insert(worker);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_LE(outer()-&gt;idle</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Size(), outer()</span></span><span class="diff-removed">-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">workers_.size</span></span><span class="diff-removed">()</span><span class="diff-removed"><span class="diff-refine-removed">)</span></span><span class="diff-removed">;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  outer()-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">idle_workers_set_cv</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">for</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">testing</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">-&gt;Broadcast(</span></span><span class="diff-removed">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">--</span></span><span class="diff-added">outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">active</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals</span></span><span class="diff-added">_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  outer()-&gt;idle_workers_set_</span><span class="diff-added"><span class="diff-refine-added">cv</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">for</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">testing</span></span><span class="diff-added">_-&gt;</span><span class="diff-added"><span class="diff-refine-added">Signal</span></span><span class="diff-added">();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">CHECK_GE(</span></span><span class="diff-added">outer()-&gt;</span><span class="diff-added"><span class="diff-refine-added">num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">active</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">, 0</span></span><span class="diff-added">);
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate::RecordUnnecessaryWakeup() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate::RecordUnnecessaryWakeup() {
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);</span></span><span class="diff-added">
</span><span class="diff-context">   RecordUnnecessaryWakeupImpl();
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::JoinForTesting() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::JoinForTesting() {
</span><span class="diff-context">   decltype(workers_) workers_copy;
   {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    SemaphoreScopedCommandsExecutor executor(this);
</span><span class="diff-context">     CheckedAutoLock auto_lock(lock_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">    AnnotateAcquiredLockAlias alias(lock_, executor.outer()-&gt;lock_);
</span><span class="diff-context">     priority_queue_.EnableFlushTaskSourcesOnDestroyForTesting();
 
     DCHECK_GT(workers_.size(), size_t(0))
         &lt;&lt; "Joined an unstarted thread group.";
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_ = true</span></span><span class="diff-removed">;
</span><span class="diff-indicator-added">+</span><span class="diff-added">    join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_</span><span class="diff-added"><span class="diff-refine-added">.Set()</span></span><span class="diff-added">;
</span><span class="diff-context"> 
     // Ensure WorkerThreads in |workers_| do not attempt to cleanup while
     // being joined.
</span><span class="diff-hunk-header">@@ -414,9 +423,16 @@</span>
<span class="diff-context">     // WorkerThread::JoinForTesting() without holding |lock_| since
     // WorkerThreads may need to access |workers_|.
     workers_copy = workers_;
</span><span class="diff-indicator-added">+</span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    // The semaphore is signaled in JoinForTesting.
</span><span class="diff-indicator-added">+</span><span class="diff-added">    num_active_signals_ += workers_copy.size();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    for (size_t i = 0; i &lt; workers_copy.size(); ++i) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">      executor.ScheduleSignal();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    }
</span><span class="diff-indicator-added">+</span><span class="diff-added">    join_called_for_testing_.Set();
</span><span class="diff-context">   }
   for (const auto&amp; worker : workers_copy) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    static_cast&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">*&gt;(worker.get())-&gt;JoinForTesting();
</span><span class="diff-indicator-added">+</span><span class="diff-added">    static_cast&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">*&gt;(worker.get())-&gt;JoinForTesting();
</span><span class="diff-context">   }
 
   CheckedAutoLock auto_lock(lock_);
</span><span class="diff-hunk-header">@@ -425,115 +441,79 @@</span>
<span class="diff-context">   workers_.clear();
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">size_t ThreadGroupImpl::NumberOfIdleWorkersLockRequiredForTesting() const {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  return idle_workers_set_.Size();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::</span><span class="diff-removed"><span class="diff-refine-removed">MaintainAtLeastOneIdle</span></span><span class="diff-removed">WorkerLockRequired(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    ScopedCommandsExecutor* executor) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::</span><span class="diff-added"><span class="diff-refine-added">CreateAndRegister</span></span><span class="diff-added">WorkerLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor* executor) {
</span><span class="diff-context">   if (workers_.size() == kMaxNumberOfWorkers) {
     return;
   }
   DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (!idle_workers_set_.IsEmpty()) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    return;
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context">   if (workers_.size() &gt;= max_tasks_) {
     return;
   }
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  scoped_refptr&lt;WorkerThreadWaitableEvent&gt; new_worker =
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">      CreateAndRegisterWorkerLockRequired(executor);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK(new_worker);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  idle_workers_set_.Insert(new_worker.get());
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">scoped_refptr&lt;WorkerThreadWaitableEvent&gt;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">ThreadGroupImpl::CreateAndRegisterWorkerLockRequired(
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">    ScopedCommandsExecutor* executor) {
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  DCHECK(!join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_LT(workers_.size(), max_tasks_);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK(idle_workers_set_</span></span><span class="diff-removed">.Is</span><span class="diff-removed"><span class="diff-refine-removed">Empty</span></span><span class="diff-removed">());
</span><span class="diff-indicator-added">+</span><span class="diff-added">  DCHECK(!join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_.Is</span><span class="diff-added"><span class="diff-refine-added">Set</span></span><span class="diff-added">());
</span><span class="diff-context"> 
   // WorkerThread needs |lock_| as a predecessor for its thread lock because in
   // GetWork(), |lock_| is first acquired and then the thread lock is acquired
   // when GetLastUsedTime() is called on the worker by CanGetWorkLockRequired().
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  scoped_refptr&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">&gt; worker =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      MakeRefCounted&lt;WorkerThread</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">&gt;(
</span><span class="diff-indicator-added">+</span><span class="diff-added">  scoped_refptr&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">&gt; worker =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      MakeRefCounted&lt;WorkerThread</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">&gt;(
</span><span class="diff-context">           thread_type_hint_,
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">          std::make_unique&lt;</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">              tracked_ref_factory_.GetTrackedRef(),
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">              /* is_excess=*/after_start().no_worker_reclaim
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                  ? workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.size() &gt;= after</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">start().initial</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">max</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">tasks
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">                  : true</span></span><span class="diff-removed">),
</span><span class="diff-indicator-added">+</span><span class="diff-added">          std::make_unique&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate&gt;(
</span><span class="diff-indicator-added">+</span><span class="diff-added">              tracked_ref_factory_.GetTrackedRef(), </span><span class="diff-added"><span class="diff-refine-added">&amp;join</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">called</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">for</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">testing</span></span><span class="diff-added">_),
</span><span class="diff-context">           task_tracker_, worker_sequence_num_++, &amp;lock_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">DCHECK(worker);</span></span><span class="diff-added">
</span><span class="diff-context">   workers_.push_back(worker);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  executor-&gt;ScheduleStart(worker);
</span><span class="diff-context">   DCHECK_LE(workers_.size(), max_tasks_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> worker</span><span class="diff-removed"><span class="diff-refine-removed">;
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">}</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed"><span class="diff-refine-removed">size_t</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">ThreadGroupImpl::GetNumAwakeWorkersLockRequired()</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">const</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">{</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK_GE(</span></span><span class="diff-removed">workers_.size()</span><span class="diff-removed"><span class="diff-refine-removed">,</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">idle_workers_set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Size</span></span><span class="diff-removed">())</span><span class="diff-removed"><span class="diff-refine-removed">;</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">size_t</span></span><span class="diff-removed"> num_</span><span class="diff-removed"><span class="diff-refine-removed">awake_w</span></span><span class="diff-removed">orkers </span><span class="diff-removed"><span class="diff-refine-removed">= wor</span></span><span class="diff-removed">k</span><span class="diff-removed"><span class="diff-refine-removed">ers_.size() - idle</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_.</span><span class="diff-removed"><span class="diff-refine-removed">Size();
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  DCHECK</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">GE</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">num_awake_workers</span></span><span class="diff-removed">, </span><span class="diff-removed"><span class="diff-refine-removed">num_running</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">tasks</span></span><span class="diff-removed">_);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">return</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">num_awake_workers</span></span><span class="diff-removed">;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">if</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">(after_start().no_</span></span><span class="diff-added">worker</span><span class="diff-added"><span class="diff-refine-added">_reclaim</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">&amp;&amp;</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">      workers_.size() </span><span class="diff-added"><span class="diff-refine-added">&gt; after</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">start</span></span><span class="diff-added">()</span><span class="diff-added"><span class="diff-refine-added">.initial_max_tasks</span></span><span class="diff-added">) </span><span class="diff-added"><span class="diff-refine-added">{</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">    num_workers_</span><span class="diff-added"><span class="diff-refine-added">in</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">excess</span></span><span class="diff-added">_.</span><span class="diff-added"><span class="diff-refine-added">fetch</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">add</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">1</span></span><span class="diff-added">, </span><span class="diff-added"><span class="diff-refine-added">std::memory</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">order</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">relaxed</span></span><span class="diff-added">);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">}</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  executor-&gt;ScheduleStart(worker)</span></span><span class="diff-added">;
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::DidUpdateCanRunPolicy() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::DidUpdateCanRunPolicy() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   CheckedAutoLock auto_lock(lock_);
   EnsureEnoughWorkersLockRequired(&amp;executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">ThreadGroup::ThreadGroupWorkerDelegate* ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::GetWorkerDelegate(
</span><span class="diff-indicator-added">+</span><span class="diff-added">ThreadGroup::ThreadGroupWorkerDelegate* ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::GetWorkerDelegate(
</span><span class="diff-context">     WorkerThread* worker) {
   return static_cast&lt;ThreadGroup::ThreadGroupWorkerDelegate*&gt;(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;</span><span class="diff-removed"><span class="diff-refine-removed">WaitableEvent</span></span><span class="diff-removed">WorkerDelegate*&gt;(worker-&gt;delegate()));
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">WorkerDelegate*&gt;(worker-&gt;delegate()));
</span><span class="diff-context"> }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::OnShutdownStarted() {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor executor(this);
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::OnShutdownStarted() {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor executor(this);
</span><span class="diff-context">   OnShutDownStartedImpl(&amp;executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">void ThreadGroup</span><span class="diff-removed"><span class="diff-refine-removed">Impl</span></span><span class="diff-removed">::EnsureEnoughWorkersLockRequired(
</span><span class="diff-indicator-added">+</span><span class="diff-added">void ThreadGroup</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">::EnsureEnoughWorkersLockRequired(
</span><span class="diff-context">     BaseScopedCommandsExecutor* base_executor) {
   // Don't do anything if the thread group isn't started.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  if (max_tasks_ == 0 || UNLIKELY(join_for_testing_</span><span class="diff-removed"><span class="diff-refine-removed">started_</span></span><span class="diff-removed">)) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">  if (max_tasks_ == 0 || UNLIKELY(join_</span><span class="diff-added"><span class="diff-refine-added">called_</span></span><span class="diff-added">for_testing_</span><span class="diff-added"><span class="diff-refine-added">.IsSet()</span></span><span class="diff-added">)) {
</span><span class="diff-context">     return;
   }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  ScopedCommandsExecutor* executor =
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      static_cast&lt;ScopedCommandsExecutor*&gt;(base_executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor* executor =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      static_cast&lt;</span><span class="diff-added"><span class="diff-refine-added">Semaphore</span></span><span class="diff-added">ScopedCommandsExecutor*&gt;(base_executor);
</span><span class="diff-context"> 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const size_t desired_</span><span class="diff-removed"><span class="diff-refine-removed">num_</span></span><span class="diff-removed">awake_workers =
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">      GetDesiredNumAwakeWorkersLockRequired();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  const size_t num_</span><span class="diff-removed"><span class="diff-refine-removed">awake_</span></span><span class="diff-removed">workers = </span><span class="diff-removed"><span class="diff-refine-removed">GetNumAwakeWorkersLockRequired();</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  size_t num_workers_</span><span class="diff-removed"><span class="diff-refine-removed">to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wake</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">up =</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">      ClampSub(desired_</span><span class="diff-removed"><span class="diff-refine-removed">num_awake_workers, num_</span></span><span class="diff-removed">awake_workers</span><span class="diff-removed"><span class="diff-refine-removed">);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">num_workers_to_wake_up</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">=</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">std::min(num_</span></span><span class="diff-removed">workers_</span><span class="diff-removed"><span class="diff-refine-removed">to_wake_up,</span></span><span class="diff-removed"> size</span><span class="diff-removed"><span class="diff-refine-removed">_t</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">2U</span></span><span class="diff-removed">));
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // Wake up the appropriate number of workers.
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  for (size_t i = 0; i &lt; num_workers_to_</span><span class="diff-removed"><span class="diff-refine-removed">wake_up</span></span><span class="diff-removed">; ++i) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">MaintainAtLeastOneIdle</span></span><span class="diff-removed">WorkerLockRequired(executor);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">WorkerThreadWaitableEvent*</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">worker</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wakeup</span></span><span class="diff-removed"> = </span><span class="diff-removed"><span class="diff-refine-removed">idle</span></span><span class="diff-removed">_workers_</span><span class="diff-removed"><span class="diff-refine-removed">set</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">.Take(</span></span><span class="diff-removed">);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">DCHECK</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker_to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wakeup);
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">    executor-&gt;</span><span class="diff-removed"><span class="diff-refine-removed">ScheduleWakeUp</span></span><span class="diff-removed">(</span><span class="diff-removed"><span class="diff-refine-removed">worker_to</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">wakeup</span></span><span class="diff-removed">);
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">}
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // In the case where the loop above didn't wake up any worker and we don't
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // have excess workers, the idle worker should be maintained. This happens
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // when called from the last worker awake, or a recent increase in</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">|max</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">tasks|
</span></span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed"><span class="diff-refine-removed">  // now makes it possible to keep an</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">idle</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">worker.</span></span><span class="diff-removed">
</span><span class="diff-indicator-removed"><span class="diff-refine-removed">-</span></span><span class="diff-removed">  </span><span class="diff-removed"><span class="diff-refine-removed">if</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">(desired_num_awake</span></span><span class="diff-removed">_</span><span class="diff-removed"><span class="diff-refine-removed">workers ==</span></span><span class="diff-removed"> </span><span class="diff-removed"><span class="diff-refine-removed">num_awake_workers</span></span><span class="diff-removed">) {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    </span><span class="diff-removed"><span class="diff-refine-removed">MaintainAtLeastOneIdleWorkerLockRequired(</span></span><span class="diff-removed">executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  const size_t desired_awake_workers = GetDesiredNumAwakeWorkersLockRequired();
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">// The +1 here is due to the fact that we always want there to be one idle
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">  // worker.
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  const size_t num_workers</span><span class="diff-added"><span class="diff-refine-added">_to_create</span></span><span class="diff-added"> =
</span><span class="diff-indicator-added">+</span><span class="diff-added">      </span><span class="diff-added"><span class="diff-refine-added">std::min({static_cast&lt;</span></span><span class="diff-added">size_t</span><span class="diff-added"><span class="diff-refine-added">&gt;(after_start().max_</span></span><span class="diff-added">num_workers_</span><span class="diff-added"><span class="diff-refine-added">created),
</span></span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">                static</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">cast&lt;size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t&gt;(</span></span><span class="diff-added">
</span><span class="diff-indicator-added">+</span><span class="diff-added">                    ClampSub(desired_awake_workers </span><span class="diff-added"><span class="diff-refine-added">+</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">1,</span></span><span class="diff-added"> workers_</span><span class="diff-added"><span class="diff-refine-added">.</span></span><span class="diff-added">size())</span><span class="diff-added"><span class="diff-refine-added">)})</span></span><span class="diff-added">;
</span><span class="diff-indicator-added">+</span><span class="diff-added">  for (size_t i = 0; i &lt; num_workers_to_</span><span class="diff-added"><span class="diff-refine-added">create</span></span><span class="diff-added">; ++i) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    </span><span class="diff-added"><span class="diff-refine-added">CreateAndRegister</span></span><span class="diff-added">WorkerLockRequired(executor);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">}</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">const size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t new</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals</span></span><span class="diff-added"> =
</span><span class="diff-indicator-added"><span class="diff-refine-added">+</span></span><span class="diff-added"><span class="diff-refine-added">      ClampSub(desired_awake</span></span><span class="diff-added">_workers</span><span class="diff-added"><span class="diff-refine-added">, num</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">active_signals</span></span><span class="diff-added">_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">AnnotateAcquiredLockAlias</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">alias</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">lock</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">,</span></span><span class="diff-added"> executor-&gt;</span><span class="diff-added"><span class="diff-refine-added">outer</span></span><span class="diff-added">(</span><span class="diff-added"><span class="diff-refine-added">)-&gt;lock</span></span><span class="diff-added">_);
</span><span class="diff-indicator-added">+</span><span class="diff-added">  </span><span class="diff-added"><span class="diff-refine-added">for</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">(size</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">t</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">i</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">=</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">0;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">i</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">&lt;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">new</span></span><span class="diff-added">_</span><span class="diff-added"><span class="diff-refine-added">signals;</span></span><span class="diff-added"> </span><span class="diff-added"><span class="diff-refine-added">++i</span></span><span class="diff-added">) {
</span><span class="diff-indicator-added">+</span><span class="diff-added">    executor</span><span class="diff-added"><span class="diff-refine-added">-&gt;ScheduleSignal(</span></span><span class="diff-added">);
</span><span class="diff-context">   }
 
   // This function is called every time a task source is (re-)enqueued,
</span><span class="diff-hunk-header">@@ -544,14 +524,5 @@</span>
<span class="diff-context">   MaybeScheduleAdjustMaxTasksLockRequired(executor);
 }
 
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">bool ThreadGroupImpl::IsOnIdleSetLockRequired(
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">    WorkerThreadWaitableEvent* worker) const {
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // To avoid searching through the idle set : use GetLastUsedTime() not being
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // null (or being directly on top of the idle set) as a proxy for being on
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  // the idle set.
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">  return idle_workers_set_.Peek() == worker ||
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">         !worker-&gt;GetLastUsedTime().is_null();
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">}
</span><span class="diff-indicator-removed">-</span><span class="diff-removed">
</span><span class="diff-context"> }  // namespace internal
 }  // namespace base

Diff finished.  Wed Jan 24 16:42:16 2024
</span></pre>
  </body>
</html>
